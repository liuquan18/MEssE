#!/usr/bin/bash

#=============================================================================
#SBATCH --account=mh0033
#SBATCH --job-name=hist_b4b6
#SBATCH --partition=compute
#SBATCH --chdir=/work/mh0033/m300883/Project_week/MEssE/build/messe_env/build_dir/icon-model/run
#SBATCH --nodes=40
#SBATCH --output=LOG.hist_b4b6.%j.o
#SBATCH --exclusive
#SBATCH --time=01:00:00
##SBATCH --qos=devel
#SBATCH --mem=0
#=============================================================================
# senexp for decorr_*
# Branch: Qtop Bugfix rwirth/coupled-seaice-qtop merged with master, 29.02.2024
#         jsbach in ICON master
#         (jsbach 3c1817f5 with new hydrology still not in ICON master, this caused error by compiling)
# Jsbach data: CERISE
# Namelist setups from slo1639 (r2b5-130lev/r2b6)
# r2b5-130lev/r2b6, full radiation, with modis cdnc
# oce started from slo1630/1800
# atm started from ifs
#=============================================================================
set -x
#=============================================================================
#
# ICON run script:
# !ATTENTION! Do not change the format of the following lines.
#             They are evaluated by checksuite scripts.
# created by ./make_target_runscript
# target machine is bull_milan
# target use_compiler is intel
# with_mpi=yes
# with_openmp=no
# memory_model=default
# submit with sbatch
#
builder=bull_milan_intel
#=============================================================================
#
# OpenMP environment variables
# ----------------------------
export OMP_NUM_THREADS=1
export ICON_THREADS=1
export OMP_SCHEDULE=dynamic,1
export OMP_DYNAMIC="false"
export OMP_STACKSIZE=200M
#
# MPI variables
# -------------
no_of_nodes=${SLURM_JOB_NUM_NODES:=4}
mpi_procs_pernode=$(( 128 * 1))
((mpi_total_procs=no_of_nodes * mpi_procs_pernode))
#
# blocking length
# ---------------
nproma=32
nproma_sub=32
nblocks_c=0
proc0_shift=0
#
# Ecrad solver (0 for CPU/vector, 2 for GPU)
# ------------------------------------------
radiation_ecrad_isolver=0
#
#=============================================================================

# load local setting, if existing
# -------------------------------
if [ -a ../setting ]
then
  echo "Load Setting"
  . ../setting
fi

# environment variables for the experiment and the target system
# --------------------------------------------------------------
# DD fix expt name
export EXPNAME="hist_b4b6"
export MALLOC_TRIM_THRESHOLD_="-1"
export SLURM_DIST_PLANESIZE="32"
export KMP_AFFINITY="granularity=fine,scatter"
export KMP_LIBRARY="turnaround"
export MALLOC_TRIM_THRESHOLD_="-1"
export MKL_DEBUG_CPU_TYPE="5"
export MKL_ENABLE_INSTRUCTIONS="AVX2"
export OMPI_MCA_btl="self"
export OMPI_MCA_coll="^ml,hcoll"
export OMPI_MCA_io="romio321"
export OMPI_MCA_osc="ucx"
export OMPI_MCA_pml="ucx"
export OMPI_MCA_coll_tuned_use_dynamic_rules="true"
export OMPI_MCA_coll_tuned_alltoallv_algorithm=2
export OMPI_MCA_pml_ucx_opal_mem_hooks=1
export UCX_HANDLE_ERRORS="bt"
export UCX_TLS="shm,dc_mlx5,dc_x,self"
export UCX_UNIFIED_MODE="y"
# load profile
# ------------
if [[ -a  /etc/profile ]]
then
	. /etc/profile
fi
#=============================================================================
# load modules
# DD fix path
loadmodule="/work/mh1494/m300466/CPP/cold-pacific-puzzle/build_hdint/etc/Modules/icon-levante"
module load $loadmodule
module list
#=============================================================================

#=============================================================================
# directories with absolute paths
# -------------------------------
thisdir=$(pwd)
# DD fix path
export basedir="/work/mh0033/m300883/Project_week/MEssE/build/messe_env/build_dir/icon-model"
export icondata="/pool/data/ICON/releases/2.6.4"
# experiments_dir can be predefined in a machine specific run_target_* header
experiments_dir="/work/mh0033/m300883/Project_week/MEssE/experiment_global"
mkdir -p ${experiments_dir}/${EXPNAME}

#
# not used yet
#export icondata="/pool/data/ICON/releases/2.6.4"
#export icon_data_rootFolder="/pool/data/ICON"

# how to start the icon model
# ---------------------------
export MODEL="${basedir}/bin/icon"                             #  generic executable

# DD: dkrz fix of work-dir performance problem (29.09.25)
sbcast -f "$MODEL" /tmp/icon
export MODEL="/tmp/icon"


#export START="srun -l  --hint=nomultithread   --distribution=block:cyclic --multi-prog ${experiments_dir}/${EXPNAME}/mpmd.lst"
export START="srun -l --kill-on-bad-exit=1 --nodes=${SLURM_JOB_NUM_NODES:-1} --distribution=block:cyclic --hint=nomultithread --ntasks=$((no_of_nodes * mpi_procs_pernode)) --ntasks-per-node=${mpi_procs_pernode} --cpus-per-task=${OMP_NUM_THREADS}"





set | grep SLURM

# how to submit the next job
# --------------------------
submit="sbatch"
job_name="exp.${EXPNAME}.run"

# cdo for post-processing
# -----------------------
cdo="cdo"
cdo_diff="cdo diffn"

# define script functions used in the experiment run script
# ---------------------------------------------------------
. ${basedir}/run/add_run_routines

#=============================================================================

ulimit -s unlimited
ulimit -c 0

#==================================================================================================
#
# ICON-ESM R2B4 NWP atmosphere coupled to R2B6 ocean
#
author_list="Helmuth Haak, Dian Putrasahan"
#
#--------------------------------------------------------------------------------------------------
#
# exp.seamless-prototype3_r2b5b7 with externally coupled HD
#
# Basic test case for the ICON-NWP coupled to the ICON-O.
#
# This basic coupled test case (Prototype 3, incl. jsbach/vdiff/HD) computes a few
# days of a global weather forecast (ICON-NWP) coupled to a global ocean (ICON-O).
# The system is set up on an NWP atmospheric grid coupled to the Ruby-0 ocean.
# The purpose is the technical testing of the coupled setup.

#
# This section of the run script contains the specifications of the experiment.
# The specifications are passed by namelist to the program.
# For a complete list see Namelist_overview.pdf
#
# Initial revision: 2023-05-05 (slo1581-slo1601), S. Lorenz, MPI-M
# changed to yac3.0 2023-09-06 (slo1620-slo1668), S. Lorenz, MPI-M
# changed to HDext  2024-04-11 (slo1669-slo1807), S. Lorenz, MPI-M
#
#--------------------------------------------------------------------------------------------------

# (0) Basic model configuration
# -----------------------------

# nproma = blocking length for array dimensioning and inner loop lengths
nproma_atm=16
nproma_oce=16

# asynchronous diagnostic output processes
# ----------------------------------------

# Note that "mpi_atm_io_procs" should match the number of output streams
#  - all output streams must set include_last=.false.
mpi_atm_io_procs=5
mpi_oce_io_procs=4

# Number of multifile restart output streams (restart_write_mode)
num_rest_atm_mpi=4
num_rest_oce_mpi=8

# Number of mpi processes per node - depends of number of openmp-threads in hybrid mode
#  - 128 total procs available - no multithreading recommended
#  - 4-8 openmp threads recommended
oce_per_node=40	#35 # 46 with 33 nodes
atm_per_node=$((mpi_procs_pernode - oce_per_node))
oce_procs=$((no_of_nodes * oce_per_node))
mpi_oce_procs=$oce_procs
atm_procs=$((no_of_nodes * atm_per_node))
omp_mpi_pernode=$((OMP_NUM_THREADS * mpi_procs_pernode))

#  - calculate procs for decomposition (io_procs subtracted):
oce_decom_procs=$((oce_procs - mpi_oce_io_procs))
atm_decom_procs=$((atm_procs - mpi_atm_io_procs))

# (1) Basic grid configuration
# -----------------------------

atmos_gridID="0012"             #  icon-nwp grid
atmos_refinement="R02B04"

ocean_gridID="0035"             #  icon-oce r2b6 grid
ocean_refinement="R02B06"

#--------------------------------------------------------------------------------------------------
#
# (2) Define the model time stepping
# ----------------------------------
#
# NWP:
dtime=450                        # NWP atmospheric timestep (s)   (same as in atmTimeStep!!)
dt_rad=3600.                     # NWP radiation timestep (s) - must match coupling/ocean time step
oceTimeStep="PT30M"              # ocean time step (30min for r2b6)
atmTimeStep="PT450S"             # atmos time step (for coupler)  (same as dtime!!)
dt=86400                         # time step for HD, set in namelist.hd
ocecouplingTimeStep="PT60M"      # coupling time step atm<->oce
#longcouplingTimeStep="P100Y"     # no coupling (long coupling period)
#rivcouplingTimeStep="P01D"       # coupling time step atm->riv->oce for HDext

#--------------------------------------------------------------------------------------------------

# (3) Set variables to configure the experiment:
# ----------------------------------------------

# start and end date+time of experiment
# -------------------------------------
#start_date=${start_date:="2240-01-01T00:00:00Z"}
#    end_date=${end_date:="2250-01-03T00:00:00Z"}
start_date=${start_date:="1950-01-01T00:00:00Z"}
    end_date=${end_date:="2015-01-02T00:00:00Z"}
start_year=$(( ${start_date%%-*} - 1 ))
  end_year=$(( ${end_date%%-*}   + 1 ))

# initialization/restart
# ----------------------
#
# Use alternatively:
  initialiseOcean="fromRestart"        # ocean is setup from restart-file, atmosphere + hd cold-started from scratch
# initialiseOcean="fromClimatology"    # ocean is setup from climatology, atmosphere + hd cold-started from scratch
#initialiseOcean="fromExperiment"     # atmos and ocean restarts from experiment specified below
# restart=.true.                       # deactivate semaphore mechanism - use restart files for atmos and ocean

# variables for start from an existing experiment (use "fromExperiment")
#  - needs links to $restart_dir etc. near "AUTOMATIC_RESTART_SETUP"
restart_dir="/work/mh0287/m211032/Icon/Git_lev/icon.XPP.20240717/build.intel-hdint/experiments"
#restart_dir=".."   #  from the same experiment directory
restart_exp=slo1780
restart_yea=1780
#
#  restart from Helmuths hel24182-1250y - restarts are in directory restart_dir/restart_exp/restart:
#restart_dir="/work/mh0033/m211054/projects/icon/seamless/icon-2aeb62/build_hdext/experiments/hel25057_b5b7_ctrl"
#restart_exp=hel25057_b5b7_ctrl
#restart_yea=1710

# set initialiseOcean automatically to false, except for first job, via semaphore mechanism (isRestartRun.sem)
if [ -d "$experiments_dir/$EXPNAME" ] ; then
  if [ -f "$experiments_dir/$EXPNAME/isRestartRun.sem" ]; then
    initialiseOcean="FALSE"
#
#  model initialised from ocean climatology: decrease ocean timestep for the first job or year:
  else
    if [[ "$initialiseOcean" == "fromClimatology" ]]; then
      oceTimeStep="PT15M"              # shorter ocean time step
    fi
  fi
fi

#-----------------------------------------------------------------------------

# (4) Output and restart file selection
# -------------------------------------

# restart/file/output intervals
# -----------------------------

# experiment stops after restart_interval, restart and output files are written once per job
#restart_interval="P2D"                             #  test run <1 min
#restart_interval="P10D"                           #  test run <30 min
#restart_interval="P3M"                             #  3m-test <30 min
#restart_interval="P10Y"                            #  production run (b4-b6)
#restart_interval="P5Y"                             #  production run (b5-b7)
#restart_interval="P2Y"                             #  production run
restart_interval="P1Y"                             #  production run  (annual)

# file interval must be longer than restart-interval
atm_file_interval="P50Y"
oce_file_interval="P50Y"

# output interval
#all_output_interval="PT30M"    # short test
#all_output_interval="PT6H"     # short test
#all_output_interval="P1D"      # daily output
all_output_interval="P1M"      # monthly output - production

# output file selection
# ---------------------
# output_<xyz>=yes : yes --> output files for <xyz>, any other value --> no files for <xyz>

# monitoring output switches
output_atm_mon=yes
output_lnd_mon=yes
output_oce_mon=yes

# ocean output switches
output_oce_moc=no      #  calc_moc is called every timestep - switch off for high resolutions
output_oce_ice=no      #  sea-ice, SST and some deeper levels
output_oce_qps=yes      #  sea-ice, SST and some deeper levels
output_oce_tke=no      #  sea-ice, SST and some deeper levels
output_oce_kin=no      #  sea-ice, SST and some deeper levels
output_oce_flx=yes      #  sea-ice, SST and some deeper levels

# atmos output switches
output_atm_icon=no      #  time mean (debug) output on native grid
output_atm_latlon=no    #  remapped spot output (1x1 deg grid)
output_atm_2d=yes       #  regular output for pyicon on native grid
output_atm_3d=yes       #  regular output for pyicon on native grid
output_jsb_2d=yes       #  time mean output on native grid for jsbach
#
output_atm_hfreq=no     #  high frequency output of atmos 3d files
atm_hfreq_output_interval="PT6H"  # 6-hourly output for atm_hfreq=yes

# standard debug-flux arrays at surface for coupling debug purpose
output_oce_dbg=no      #  ocean surface fluxes DD: yes need for ENSO metric
output_atm_spot=no      #  spot (debug) output on native grid - incl. lsm_switch, lsm_ctr_c etc.
output_lnd_dbg=no       #  spot (debug) output on native grid for jsbach



# output time of geometry file fx:
start_fx="1700-01-02T00:00:00Z"

# output switches for large atm/oce files - set to "yes" if needed for standard quickplots
#  - yes writes much output and needs more computing time at least in high resolution
output_oce_def=no             # annual mean is sufficient
oce_output_interval_def="P1Y"  # annual mean output for deep ocean
# monthly output interval for at least monitoring output if all_output is annual
#mon_output_interval="P1M"

# more specs:
# atm_output_interval=$atmTimeStep     #  output every timestep
# oce_output_interval=$oceTimeStep     #  output every timestep
atm_output_interval=$all_output_interval
oce_output_interval=$all_output_interval
checkpoint_interval="P50Y"             #  write checkpoint

# output interval for large atm/oce files, normally set to general interval:
#atm_output_interval_3d="$atm_output_interval"
#atm_output_interval_2d="$atm_output_interval"

# output switches for HAMOCC files
# - not yet

# namelist files
# --------------
atm_namelist=NAMELIST_${EXPNAME}_atm
oce_namelist=NAMELIST_${EXPNAME}_oce
lnd_namelist=NAMELIST_${EXPNAME}_lnd

echo "============================================"
echo " #configinfo#  number of nodes: $no_of_nodes"
echo " #configinfo#  OMP_NUM_THREADS = $OMP_NUM_THREADS"
echo " #configinfo#  OMP * MPI pernode = $omp_mpi_pernode"
echo " #configinfo#  mpi_procs_pernode = $mpi_procs_pernode"
echo " #configinfo#  mpi_total_procs = $mpi_total_procs"
echo " #configinfo#  mpi_atm_io_procs=$mpi_atm_io_procs"
echo " #configinfo#  mpi_oce_io_procs=$mpi_oce_io_procs"
echo " #configinfo#  oce_per_node = $oce_per_node"
echo " #configinfo#  atm_per_node = $atm_per_node"
echo " #configinfo#  atm_procs = $atm_procs (incl. io_procs)"
echo " #configinfo#  oce_procs = $oce_procs (incl. io_procs)"
echo " #configinfo#  oce_decom_procs = $oce_decom_procs"
echo " #configinfo#  atm_decom_procs = $atm_decom_procs"
echo " #configinfo#  num_rest_atm_mpi=$num_rest_atm_mpi"
echo " #configinfo#  num_rest_oce_mpi=$num_rest_oce_mpi"
echo " #configinfo#  nproma_atm = $nproma_atm"
echo " #configinfo#  nproma_oce = $nproma_oce"
echo "============================================"

#-----------------------------------------------------------------------------
# Some time parameters for HD and model control:
#  - Create year.log file - determines current year and stop year for namelist.hd:
#  - HDmode=HDext not yet fully implemented

HDmode=HDint

if  [[ $HDmode = "HDext" ]]; then
#  in namelist_atm
  COUPLEDTOHYDRODISC="coupled_to_hydrodisc = .TRUE."
else
  COUPLEDTOHYDRODISC=!
fi

if [ ! -f ${experiments_dir}/${EXPNAME}/year.log ] ; then

# initialise atmosphere: start year of coupled run is set by start_date:
  if [ "$initialiseOcean" == "fromRestart" -o "$initialiseOcean" == "fromClimatology" ] ; then
    syear=${start_date:0:4}
  fi
# restart atmosphere, ocean, hd: start year of coupled run is set by restart_yea
  if [ "$initialiseOcean" == "fromExperiment" ] ; then
    syear=${restart_yea}
  fi
# initialise year.log fie
  echo ${syear} > ${experiments_dir}/${EXPNAME}/year.log
fi

# read current year
current_year=$(cat ${experiments_dir}/${EXPNAME}/year.log)
let prev_year=${current_year}-1

# next year is dependent on restart interval:
if  [[ $restart_interval = "P10Y" ]]; then
  let next_year=($current_year+10)
  let stop_year=($current_year+9)
elif [[ $restart_interval = "P5Y" ]]; then
  let next_year=($current_year+5)
  let stop_year=($current_year+4)
elif [[ $restart_interval = "P2Y" ]]; then
  let next_year=($current_year+2)
  let stop_year=($current_year+1)
#  for HDint: use nextyear for all intervals
elif [[ $restart_interval = "P1Y" ]]; then
  let next_year=($current_year+1)
  stop_year=$current_year
else
  if  [[ $HDmode = "HDext" ]]; then
  echo 'restart_interval is different from P1Y/P2Y/P5Y/P10Y. Reset next_year, stop_year!'
  exit
  else
    let next_year=($current_year+1)
    stop_year=$current_year
  fi
fi

echo " ### Restart interval = $restart_interval"
echo " ###  start year of this job = $current_year "
echo " ###   stop year of this job = $stop_year "
echo " ###  start year of next job = $next_year "
echo " ###  end year of experiment = $end_year "


#--------------------------------------------------------------------------------------------------
# Input data directories:
clim_data_poolFolder=/pool/data/ICON/edzw-shadow
icon_data_poolFolder=/pool/data/ICON/grids/public
atmo_data_InputFolder=${clim_data_poolFolder}/${atmos_gridID}
#
#  preliminary Setup dir of Stephan:
ICONcoupled="/work/mh0033/m300883/Project_week/MEssE"
SetupXPP="${ICONcoupled}/experiment/global_run"   

#--------------------------------------------------------------------------------------------------
# I. coupling section
#--------------------------------------------------------------------------------------------------

if [ $mpi_total_procs -lt 2 ] ; then
  check_error 0 "This setup requires at least 2 mpi processes. Exit"
fi

# I.1 Split the number of total procs and assign to each component
# ----------------------------------------------------------------
oce_min_rank=`expr ${mpi_total_procs} - ${mpi_oce_procs}`
#  1 proc for hd-extern, at least one proc for atmosphere
hdproc=0
[[ $HDmode = "HDext" ]] && hdproc=1
oce_max_rank=`expr ${oce_min_rank} + ${mpi_oce_procs} - ${hdproc} - 1`
oce_inc_rank=1
atm_min_rank=0
atm_max_rank=`expr ${oce_min_rank} - 1`
atm_inc_rank=1
#
# I.2 Fill model list
# -------------------
#
namelist_list[0]="$atm_namelist"
modelname_list[0]="atmo"
modeltype_list[0]=1
minrank_list[0]=$atm_min_rank
maxrank_list[0]=$atm_max_rank
incrank_list[0]=$atm_inc_rank
#
namelist_list[1]="$oce_namelist"
modelname_list[1]="ocean"
modeltype_list[1]=2
minrank_list[1]=$oce_min_rank
maxrank_list[1]=$oce_max_rank
incrank_list[1]=$oce_inc_rank
#
#modelname_list[2]="HD"

# I.3 YAC coupling library configuration
#-----------------------------------------------------------------------------

atm_lag=1
oce_lag=1
riv_lag=1

# co2_flux and co2_mixing_ratio are listed as transients
# below but are not configured for coupling in the couples
# section. There fields are therefore not considered for
# the search not for the data exchange even if yac_fget and
# yac_fput are called for these fields.
#
# component names in coupling.yaml must (!) match with modelname_list[*]
#

cat > coupling_${EXPNAME}.yaml << EOF
definitions:
  atm2oce: &atm2oce
    src_component: ${modelname_list[0]}
    src_grid: icon_atmos_grid
    tgt_component: ${modelname_list[1]}
    tgt_grid: icon_ocean_grid
    time_reduction: average
    src_lag: ${atm_lag}
    tgt_lag: ${oce_lag}
  oce2atm: &oce2atm
    src_component: ${modelname_list[1]}
    src_grid: icon_ocean_grid
    tgt_component: ${modelname_list[0]}
    tgt_grid: icon_atmos_grid
    time_reduction: average
    src_lag: ${oce_lag}
    tgt_lag: ${atm_lag}
# atm2riv: &atm2riv
#   src_component: ${modelname_list[0]}
#   src_grid: icon_atmos_grid
#   tgt_component: ${modelname_list[2]}
#   tgt_grid: HD_GRID
#   time_reduction: average
#   src_lag: ${atm_lag}
#   tgt_lag: ${riv_lag}
# riv2oce: &riv2oce
#   src_component: ${modelname_list[2]}
#   src_grid: HD_GRID
#   tgt_component: ${modelname_list[1]}
#   tgt_grid: icon_ocean_grid
#   time_reduction: average
#   src_lag: ${riv_lag}
#   tgt_lag: ${oce_lag}
  interp_stacks:
    hcsbb_interp_stack: &hcsbb_interp_stack
      interpolation:
        - bernstein_bezier
        - nnn:
            n: 4
            weighted: arithmetic_average
        - fixed:
            user_value: -999.9
    conserv_interp_stack: &conserv_interp_stack
      interpolation:
        - conservative:
            order: 1
            enforced_conservation: false
            partial_coverage: true
            normalisation: fracarea
        - nnn:
            n: 4
            weighted: arithmetic_average
        - fixed:
            user_value: -999.9
#    conserv_interp_dest: &conserv_interp_dest
#      interpolation:
#        - conservative:
#            order: 1
#            enforced_conservation: false
#            partial_coverage: true
#            normalisation: destarea
    spmap_interp_stack: &spmap_interp_stack
      interpolation:
        - source_to_target_map:
            spread_distance: 0.3
            max_search_distance: 9
        - fixed:
            user_value: 0.0
timestep_unit: ISO_format
calendar: proleptic-gregorian
coupling:
  - <<: [ *atm2oce, *hcsbb_interp_stack ]
    coupling_period: ${ocecouplingTimeStep}
    field: [surface_downward_eastward_stress,
            surface_downward_northward_stress]
#  - <<: [ *atm2oce, *hcsbb_interp_stack ]
#    coupling_period: ${ocecouplingTimeStep}
#    field: [10m_wind_speed]
  - <<: [ *atm2oce, *conserv_interp_stack ]
    coupling_period: ${ocecouplingTimeStep}
    field: [surface_fresh_water_flux,
            total_heat_flux,
            atmosphere_sea_ice_bundle]
    #weight_file_name: w_atm2oce.nc
  - <<: [ *oce2atm, *conserv_interp_stack ]
    coupling_period: ${ocecouplingTimeStep}
    field: [sea_surface_temperature,
            ocean_sea_ice_bundle]
    #weight_file_name: w_oce2atm.nc
#  - <<: [ *atm2riv, *conserv_interp_dest ]
#    coupling_period: ${rivcouplingTimeStep}
#    field: [surface_water_runoff,
#            soil_water_runoff]
  - <<: [ *oce2atm, *conserv_interp_stack ]
    coupling_period: ${ocecouplingTimeStep}
    field: [surface_velocity_bundle]
#    field: [eastward_sea_water_velocity,
#            northward_sea_water_velocity]
# - <<: [ *riv2oce, *spmap_interp_stack ]
#   coupling_period: ${rivcouplingTimeStep}
#   field: river_runoff
    #weight_file_name: w_riv2oce.nc
  - <<: [ *atm2oce, *spmap_interp_stack ]
    coupling_period: ${ocecouplingTimeStep}
    field: river_runoff
EOF

# yaml files for YAC
# -------------------------
#
add_required_file ${basedir}/run/coupling_${EXPNAME}.yaml ./coupling.yaml


#
#-----------------------------------------------------------------------------
# II. ATMOSPHERE
#-----------------------------------------------------------------------------
#
#-----------------------------------------------------------------------------
# II.B JSBACH 
#-----------------------------------------------------------------------------

#--------------------
#   JSBACH data files
#--------------------

# - link lctlib from ICON repository:
add_link_file  ${basedir}/externals/jsbach/data/lctlib_nlct21.def ./

# - use new input by Veronika here - in general from pool:
#datadir="${clim_data_poolFolder}/${atmos_gridID}-${ocean_gridID}/land/r0002"
#data_land="${clim_data_poolFolder}/${atmos_gridID}-${ocean_gridID}/land"
# preliminary: by Veronika
data_land="/work/mh1421/m220053/for-pool/ICON/edzw-shadow/0012-0035"
datadir="${data_land}/land/r0002"

# - soil spinup file:
#JSBACH_SOIL_SPINUP="_vga0440"
JSBACH_SOIL_SPINUP=""

# - jsbach land data year and filenames:
JSBACH_YEAR=1950
jsbach_lnd_frac="bc_land_frac_11pfts_${JSBACH_YEAR}.nc"
jsbach_bc_phys="bc_land_phys.nc"
jsbach_bc_soil="bc_land_soil.nc"
jsbach_sso="bc_land_sso.nc"
# - jsbach soil init data
jsbach_ic_soil="ic_land_soil.nc"
#jsbach_ic_soil="ic_land_soil_${JSBACH_YEAR}${JSBACH_SOIL_SPINUP}.nc"
  
# - link land data
add_link_file ${datadir}/${jsbach_lnd_frac}             ./
add_link_file ${datadir}/${jsbach_bc_phys}              ./
add_link_file ${datadir}/${jsbach_bc_soil}              ./
add_link_file ${datadir}/${jsbach_ic_soil}              ./
add_link_file ${datadir}/${jsbach_sso}                  ./

# hd_receive: dependent on coupled resolutions:
#
# - preliminary from Helmuth, see $data_land
#hdrec_indir="$data_land/hd1_12"
#hdrec_innam="hd_receive_0030_R02B05.nc"
#hdrec_fname="hd_receive.nc"
#add_link_file $hdrec_indir/$hdrec_innam                                   ./$hdrec_fname

# - no read of albedo
extpar_filename="icon_extpar4jsbach_0012_20240801_tiles_jsb.nc"
extpar_targetname="extpar_icon_grid_0012_R02B04_G.nc"
#
add_link_file $datadir/$extpar_filename $extpar_targetname

#
# NWP ifs2icon specificatons
#  - ifs2icon requires specific name in mo_initicon_io:read_extana_atm:
#    ifs2icon_R2B05_DOM01.nc - caution: "R2B05" not "R02B05"
#
ifs_fname="ifs2icon_R2B04_DOM01.nc"                                   #  do not change name
ifs_indir="${clim_data_poolFolder}/0012/initial_condition/r0001"
ifs_innam="ifs2icon_2000010100_0012_R02B04_G.nc"
add_link_file ${ifs_indir}/${ifs_innam} ${ifs_fname}

#--------------------
# JSBACH settings
#--------------------
#

#
run_jsbach=yes                #  setting for automatic namelist at MPI - automatic?
#jsbach_usecase=jsbach_pfts    # jsbach_lite or jsbach_pfts
#jsbach_with_lakes=yes 
#jsbach_check_wbal=yes         # check water balance
#jsbach_with_carbon=no         # yes needs jsbach_pfts usecase

jsbach_namelist=$lnd_namelist  # creates jsb_model_nml automatically ???

#  jsbach namelist
#for ((i=0; i < ${#dynamics_grid_filename[@]}; i++)); do
#  ii=$(printf '%02d' $((i+1)))
#  cat > "NAMELIST_JSBACH_DOM$ii" << EOF
#ii=01
cat > $lnd_namelist << EOF
&jsb_model_nml
  usecase              = 'jsbach_pfts'
  use_lakes            = .TRUE.
  !enforce_water_budget = .TRUE.               !  general parameter for all tests - not available in release 2025-04
  fract_filename       = '${jsbach_lnd_frac}'
  !output_tiles         = ${output_tiles}     ! List of tiles to output
  init_from_ifs        = .TRUE.               ! needs ifs_filename
  ifs_filename         = '${ifs_fname}'
/
&jsb_seb_nml
  bc_filename          = '${jsbach_bc_phys}'
  ic_filename          = '${jsbach_ic_soil}'
/
&jsb_rad_nml
  use_alb_veg_simple   = .FALSE.          ! Use TRUE for jsbach_lite, FALSE for jsbach_pfts
  bc_filename          = '${jsbach_bc_phys}'
  ic_filename          = '${jsbach_ic_soil}'
/
&jsb_turb_nml
  bc_filename          = '${jsbach_bc_phys}'
  ic_filename          = '${jsbach_ic_soil}'
/
&jsb_sse_nml
  l_heat_cap_map       = .FALSE.
  l_heat_cond_map      = .FALSE.
  l_heat_cap_dyn       = .TRUE.
  l_heat_cond_dyn      = .TRUE.
  l_snow               = .TRUE.
  l_dynsnow            = .TRUE.
  l_freeze             = .TRUE.
  l_supercool          = .TRUE.
  bc_filename          = '${jsbach_bc_soil}'
  ic_filename          = '${jsbach_ic_soil}'
/
&jsb_hydro_nml
  l_organic            = .FALSE.
  bc_filename          = '${jsbach_bc_soil}'
  ic_filename          = '${jsbach_ic_soil}'
  bc_sso_filename      = '${jsbach_sso}'
/
&jsb_assimi_nml
  active               = .TRUE.              ! Use FALSE for jsbach_lite, TRUE for jsbach_pfts
/
&jsb_pheno_nml
  active               = .TRUE.
  scheme               = 'logrop'            ! scheme = logrop / climatology; use climatology for jsbach_lite
  bc_filename          = '${jsbach_bc_phys}'
  ic_filename          = '${jsbach_ic_soil}'
/
&jsb_carbon_nml
  active               = .TRUE.              ! true: use ccycle namelist
  !bc_filename          = '${jsbach_bc_carbon}'
  !ic_filename          = '${jsbach_ic_carbon}'
/
&jsb_fuel_nml
  active               = .FALSE.
  fuel_algorithm       = 1
/
&jsb_disturb_nml
  active               = .FALSE.
  ic_filename          = '${jsbach_ic_soil}'
  bc_filename          = '${jsbach_bc_phys}'
  fire_algorithm       = 1
  windbreak_algorithm  = 1
  lburn_pasture        = .FALSE.
/
 &jsb_hd_nml
   active               = .TRUE.
   routing_scheme       = 'full'               ! 'zero' no HD, runoff=0; 'full' incl. full HD model; 'weighted_to_coast'
   bc_filename          = 'bc_land_hd.nc'
   diag_water_budget    = .FALSE.
   debug_hd             = .FALSE.
!  enforce_water_budget = .TRUE.          ! TRUE: stop in case of water conservation problem
 /
EOF

# cat namelist
cat $lnd_namelist

#
#-----------------------------------------------------------------------------
# II.A ICON-NWP
#-----------------------------------------------------------------------------
#
atmo_model_equations=3 # equation system
#                     1=hydrost. atm. (T dynamics)
#                     2=hydrost. atm. (theta dynamics)
#                     3=non-hydrost. atm.,
#                    -1=shallow water model
#                    -2=hydrost. ocean
nlev=90           # nlev = number of full levels
iforcing=3        # 3 for inwp forcing; 0 for no forcing
#
#-----------------------------------------------------------------------------
#

#
# NWP atmospheric grid files
atmos_grid_folder=${icon_data_poolFolder}/edzw

# link atmos grid and grfinfo files directly
atmos_grid_source=icon_grid_${atmos_gridID}_${atmos_refinement}_G.nc
atmos_grid_target=$atmos_grid_source
add_link_file ${atmos_grid_folder}/${atmos_grid_source} ./$atmos_grid_target

# #slo - is grid-info file necessary?
#atmos_grfinfo=icon_grid_${atmos_gridID}_${atmos_refinement}_G-grfinfo.nc
#add_link_file ${atmos_grid_folder}/$atmos_grfinfo ./$atmos_grfinfo

# files needed for radiation
add_link_file ${basedir}/data/ECHAM6_CldOptProps.nc .
add_link_file ${basedir}/data/rrtmg_lw.nc .
ecRad_data_path=${basedir}'/externals/ecrad/data'

#-----------------------------------------------------------------------------
#
#   Kinne background aerosols for the year 1850 (irad_aero=12, filename without year)
#    - unified with code of icon-nwp
#
# from /pool/data/ICON/edzw-shadow/0012/aerosol_kinne/r0001
datadir=${atmo_data_InputFolder}/aerosol_kinne/r0001
add_link_file ${datadir}/bc_aeropt_kinne_lw_b16_coa.nc       ./
add_link_file ${datadir}/bc_aeropt_kinne_sw_b14_coa.nc       ./
add_link_file ${datadir}/bc_aeropt_kinne_sw_b14_fin_1850.nc             ./bc_aeropt_kinne_sw_b14_fin.nc

# stratospheric aerosol (CMIP6)
datadir=${icon_data_poolFolder}/mpim/independent/CMIP6Forcing
for year in $(seq ${prev_year} ${next_year})
do
  if [[ $year -eq 1849 ]]; then
    #add_link_file $datadir/bc_aeropt_cmip6_volc_lw_b16_sw_b14_1850.nc     ./bc_aeropt_cmip6_volc_lw_b16_sw_b14_1849.nc
    add_link_file $datadir/bc_aeropt_cmip6_volc_lw_b16_sw_b14_1850.nc     ./bc_aeropt_volc_lw_b16_sw_b14_1849.nc
  elif [[ $year -le 2014 ]]; then
    #add_link_file $datadir/bc_aeropt_cmip6_volc_lw_b16_sw_b14_${year}.nc  ./bc_aeropt_cmip6_volc_lw_b16_sw_b14_${year}.nc
    add_link_file $datadir/bc_aeropt_cmip6_volc_lw_b16_sw_b14_${year}.nc  ./bc_aeropt_volc_lw_b16_sw_b14_${year}.nc
  else
    #add_link_file $datadir/bc_aeropt_cmip6_volc_lw_b16_sw_b14_2014.nc     ./bc_aeropt_cmip6_volc_lw_b16_sw_b14_${year}.nc
    add_link_file $datadir/bc_aeropt_cmip6_volc_lw_b16_sw_b14_2014.nc     ./bc_aeropt_volc_lw_b16_sw_b14_${year}.nc
  fi
done

# tropospheric anthropogenic aerosols, simple plumes
datadir=${icon_data_poolFolder}/mpim/independent/MACv2_simple_plumes_merged
add_link_file ${datadir}/MACv2.0-SP-merged-historical-and-SSP2-45_v1.nc  ./MACv2.0-SP_v1.nc

#-----------------------------------------------------------------------------
# ozon O3: link data for irad_o3=5 - read from filename including 4-digit year
revision='r0001'
datadir=${atmo_data_InputFolder}/ozone/${revision}
# delete ozone links:
rm -f $experiments_dir/$EXPNAME/bc_ozone_????.nc

for year in $(seq ${prev_year} ${next_year})
do
  if [[ $year -eq 1849 ]]; then
    add_link_file ${datadir}/bc_ozone_historical_1850.nc    ./bc_ozone_1849.nc
  elif [[ $year -le 2014 ]]; then
    add_link_file ${datadir}/bc_ozone_historical_${year}.nc ./bc_ozone_${year}.nc
  else
    add_link_file ${datadir}/bc_ozone_historical_2014.nc    ./bc_ozone_${year}.nc
  fi
done

#-----------------------------------------------------------------------------
# solar radiation - data from MPIM
# time dependent 14-band solar insolation for 1850-2299 AD
datadir=${icon_data_poolFolder}/mpim/independent/solar_radiation/3.2
add_link_file $datadir/swflux_14band_cmip6_1849-2299-v3.2.nc ./bc_solar_irradiance_sw_b14.nc

#datadir="$SetupXPP/Solar"
#add_link_file $datadir/swfl-withY.999-2301y.nc                          ./bc_solar_irradiance_sw_b14.nc

# greenhouse gases:
datadir=${icon_data_poolFolder}/mpim/independent/greenhouse_gases
add_link_file $datadir/greenhouse_historical_plus.nc ./bc_greenhouse_gases.nc
#add_link_file $datadir/greenhouse_ssp370.nc ./bc_greenhouse_gases.nc

#-----------------------------------------------------------------------------
#
#Link data for HD:
#
if [[ $HDmode = "HDext" ]] ; then
# HD-extern: mask and hdpara are independent of atmos/ocean resolution:
datadir=${clim_data_poolFolder}/indepedent/hd/input/05deg
add_link_file $datadir/masks_05.nc                                        ./masks.nc
add_link_file $datadir/hdpara_vs1_12.nc                                   ./hdpara.nc
else
  datadir="$SetupXPP"
  add_link_file $datadir/hdpara_r2b4_0012_0035_sc_hfrac_v2.nc ./bc_land_hd.nc   #  mask for routing_scheme='full'
fi

#-----------------------------------------------------------------------------

# reconstruct the grid parameters in namelist form
dynamics_grid_filename=""
for gridfile in ${atmo_dyn_grids}; do
  dynamics_grid_filename="${dynamics_grid_filename} '${gridfile}',"
done
dynamics_parent_grid_id="${dynamics_parent_grid_id},"

#-----------------------------------------------------------------------------

# Best sleve parameters for 90/130 vertical levels:

if [ ${nlev} == 90 ] ; then
  MAXLAYTH=400.                           # maximum layer thickness below htop_thcknlimit
  TOPTHLIM=14000.                         # top limit for max_lay_thckn
  STRETFAC=0.9                            # stretch factor
  FLHEIGHT=16000.                         # flat height
elif [ ${nlev} == 130 ] ; then 
  MAXLAYTH=500.
  TOPTHLIM=35000.
  STRETFAC=1.2
  FLHEIGHT=35000.
fi

# python environment
source /work/mh0033/m300883/Project_week/MEssE/build/messe_env/py_env/bin/activate


#-----------------------------------------------------------------------------
#
# write ICON-NWP atmospheric namelist parameters
# ------------------------
# For a complete list see Namelist_overview and Namelist_overview.pdf
#
cat > ${atm_namelist} << EOF
!
&coupling_mode_nml
 coupled_to_ocean        = .TRUE.
 $COUPLEDTOHYDRODISC
/
!
&parallel_nml
 nproma                  = ${nproma_atm}
 p_test_run              = .false.
 l_fast_sum              = .false.
 l_test_openmp           = .false.
 l_log_checks            = .false.
 num_io_procs            = ${mpi_atm_io_procs}
 pio_type                = 1                   ! default 1: asynchron io
 num_restart_procs       = ${num_rest_atm_mpi} ! number of procs for multifile restart
 num_dist_array_replicas = ${replicate_grid-1} ! can be 1 iff passive or active (see HAVE_SLOW_PASSIVE_TARGET_ONESIDED) target RMA works well
/
&grid_nml
 dynamics_grid_filename  = "${atmos_grid_target}"
 dynamics_parent_grid_id = 0,1
 !lredgrid_phys           = .true.
 lredgrid_phys           = .false.
 !radiation_grid_filename = "$rad_grid_target" 
 radiation_grid_filename = " "
 lfeedback               = .false.
/ 
&run_nml
 num_lev                 = ${nlev}              ! number of full levels of vertical grid
 dtime                   = ${dtime}             ! [s] timestep in seconds
 modelTimeStep           = "${atmTimeStep}"
 ldynamics               = .TRUE.               ! dynamics
 ltransport              = .TRUE.               ! transport
 iforcing                = ${iforcing}          !
 ntracer                 =  5                   ! number of tracers - default 0
 ltimer                  = .true.               ! 
 ltestcase               = .false.              ! initialize with real data
 timers_level            = 10
 msg_level               = 1                    ! DD: reduce for speed?
! msg_level               = 5                    ! detailed report during integration (5-7 or 13 incl. seaice prints)
 output                  = 'nml'
 check_uuid_gracefully   = .true.
 Restart_filename        = "${EXPNAME}_restart_atm_<rsttime>.nc"
/
&dynamics_nml
 iequations              = ${atmo_model_equations}
 lcoriolis               = .TRUE.
 divavg_cntrwgt          = 0.50
/
&diffusion_nml
 hdiff_order             = 5
 hdiff_efdt_ratio        = 24.0
 hdiff_smag_fac          = 0.025
 lhdiff_vn               = .TRUE.
 lhdiff_temp             = .TRUE.
 hdiff_multfac           = 1.0
 hdiff_tv_ratio          = 1.0
/
&nwp_phy_nml
 !icalc_reff              = 100         ! For Modis cdnc
 !icpl_rad_reff           = 0           ! For Modis cdnc
 !icpl_aero_gscp          = 3           ! 0: no cdnc (def); 3: read and use Modis cdnc
 inwp_gscp               = 1
 inwp_convection         = 1
 inwp_radiation          = 4
 inwp_cldcover           = 1
 inwp_satad              = 1
 inwp_sso                = 1
 inwp_gwd                = 1
 latm_above_top          = .false.
 efdt_min_raylfric       = 7200.
 itype_z0                = 2
 icapdcycl               = 3
 icpl_aero_conv          = 0           ! 1 if irad_aero=6 or 9 is used - 0 for irad_aero=12
 icpl_aero_gscp          = 0           ! 1 if irad_aero=6 or 9 is used - 0 for irad_aero=12
 icpl_o3_tp              = 1
 !lshallow_liquid_only   = .true.
 dt_rad                  = ${dt_rad}
 dt_conv                 = 1800.       ! time step for convection in s (domain specific)
 dt_sso                  = 1800.       ! time step for SSO parameterization
 dt_gwd                  = 1800.       ! time step for gravity wave drag parameterization
 !! parameters for jsbach/vdiff land model:
 inwp_surface            = 2           ! 1 = terra; 2 = JSBACH
 inwp_turb               = 6           ! 1 = terra; 6 = VDIFF
/
&nwp_tuning_nml
 itune_albedo            = 0        ! 0: no MODIS tuning (def); 1: dimmed Sahara; 2: +brighter AA
 tune_zceff_min          = 0.025                     ! ** default value to be used for R3B7; use 0.025 for R2B6
 tune_gkdrag             = 0.075                     ! R2B6: 0.075  
 tune_gkwake             = 1.5                       ! R2B6: 1.5
 tune_gfrcrit            = 0.425                     ! R2B6: 0.425
 tune_dust_abs           = 0.
 tune_box_liq_asy        = 3.25    ! 3.35            ! oper global: 3.0 , oper D2: 3.25, default: 2.5
 tune_box_liq            = 0.045   ! 0.05            ! def=0.05
 tune_rcucov             = 0.075
 tune_rhebc_land         = 0.825
 tune_gust_factor        = 7.0
 icpl_turb_clc           = 1
 lcalib_clcov            = .false.        ! turn off TCC, HCC, MCC, LCC tuning
 tune_zvz0i              = 0.85            ! default: 0.85   ; Terminal fall velocity of ice
 tune_entrorg            = 1.95e-3        ! default: 1.95e-3; Entrainment parameter valid for dx=20 km
 tune_eiscrit            = 7.0            ! to switch off conv param in stratocumulus regions
 tune_sc_eis             = 7.             ! ! default: 1000. - exec newer 633d375ad0
/
&transport_nml
 ivadv_tracer            = 3,3,3,3,3
 itype_hlimit            = 3,4,4,4,4,0
 ihadv_tracer            = 32,2,2,2,2,0
/
&nonhydrostatic_nml
 iadv_rhotheta           = 2
 ivctype                 = 2
 itime_scheme            = 4
 exner_expol             = 0.333
 vwind_offctr            = 0.2          ! 0.2 for R2B6 and higher resolution, 0.3 for lower resolution
 damp_height             = 44000.                    
 rayleigh_coeff          = 0.5                       ! default: 0.05
 divdamp_order           = 24           ! 2 ass, 24 fc
 divdamp_type            = 32           ! optional: 2 assimilation cycle, 32 forecast
 divdamp_fac             = 0.004        ! 0.004 for R2B6; recommendation for R3B7: 0.003
 divdamp_trans_start     = 12500                     
 divdamp_trans_end       = 17500                     
 igradp_method           = 3	                     
 l_zdiffu_t              = .true.                    
 thslp_zdiffu            = 0.02	                     
 thhgtd_zdiffu           = 125.	                     
 htop_moist_proc         = 22500.                    
 hbot_qvsubstep          = 16000.                    
/				                     
&sleve_nml			                     
 top_height          = 75000.                         ! model top
 min_lay_thckn       = 20.         ! lowest level thickness (between half-levels)
 decay_scale_1       = 4000.
 decay_scale_2       = 2500.
 decay_exp           = 1.2
 max_lay_thckn       = $MAXLAYTH                      ! maximum layer thickness below htop_thcknlimit
 htop_thcknlimit     = $TOPTHLIM                      ! top limit for max_lay_thckn
 stretch_fac         = $STRETFAC
 flat_height         = $FLHEIGHT
/
&io_nml				                     
 lflux_avg               = .FALSE.                   ! true: averaged (ashfl_s), false: accumulated fluxes (accshfl_s)
 itype_pres_msl          = 5                         ! (1) 3: IFS-type extrapolation
 itype_rh                = 1                         ! (1) 2: mixed phase (water and ice)
 inextra_3d              = 2                         ! 3D extra variables 
 inextra_2d              = 10                        ! 2D extra variables 
 restart_write_mode      = "joint procs multifile"   ! asynchron multifile restart handling; 'sync' for single file writing
 lkeep_in_sync           = .TRUE.                    ! sync after each timestep
 lnetcdf_flt64_output    = .FALSE.                   ! T: 64 bit output in all files
/
EOF

# add COMIN plugin to ICON namelist

cat >> ${atm_namelist} << EOF
&comin_nml
   plugin_list(1)%name           = "comin_plugin"
   plugin_list(1)%plugin_library = "/work/mh0033/m300883/Project_week/MEssE/build/messe_env/build_dir/icon-model/externals/comin/build/plugins/python_adapter/libpython_adapter.so"
   plugin_list(1)%options        = "/work/mh0033/m300883/Project_week/MEssE/scripts/plugin/scripts/comin_plugin.py"
/
EOF





#  add monitoring file for atmos
if [[ "$output_atm_mon" == "yes" ]]; then

cat >> ${atm_namelist} << EOF

&output_nml
 filetype                = 4                         ! output format: 2=GRIB2, 4=NETCDFv2
 output_start            = "${start_date}"
 output_end              = "${end_date}"
 output_interval         = "${atm_output_interval}"  ! the output interval and
 file_interval           = "${atm_file_interval}"    ! the file interval
 mode                    = 1                         ! 1: forecast mode (relative t-axis)
 operation               = "mean"                    ! works on icon grid only (remap=0)
 remap                   = 0                         ! 1: latlon,  0: native grid
 include_last            = .FALSE.                   ! flag whether to include the last time step
 output_grid             = .FALSE.                   ! flag whether grid information is added to output.
 output_filename         = "${EXPNAME}_atm_mon"      ! file name base
 filename_format         = "<output_filename>_<datetime2>"
 ml_varlist              = 'tas_gmean','rsdt_gmean','rsut_gmean','rlut_gmean','radtop_gmean','prec_gmean','evap_gmean','pme_gmean'
/
EOF
fi

#  add native time mean output 2-dim averaged over OUTPUT_INTERVAL:
if [[ "$output_atm_2d" == "yes" ]]; then

cat >> ${atm_namelist} << EOF
&output_nml
 output_start            = "${start_date}"
 output_end              = "${end_date}"
 output_interval         = "${atm_output_interval}"  ! the output interval and
 file_interval           = "${atm_file_interval}"    ! the file interval
 filetype                = 4                         ! output format: 2=GRIB2, 4=NETCDFv2
 dom                     = -1		             
 mode                    =  1                        ! 1: forecast mode (relative t-axis); 2: climate mode
 include_last            = .FALSE.                   ! flag whether to include the last time step
 output_filename         = "${EXPNAME}_atm_2d_ml"    ! file name base
 filename_format         = "<output_filename>_<datetime2>"
 output_grid             = .TRUE.                    ! flag whether grid information is added to output.
 remap                   = 0                         ! 1: latlon,  0: native grid
 operation               = "mean"                    ! works on icon grid only (remap=0)
 ml_varlist              = 'pres_msl', 'pres_sfc', 't_s', 'clct', 'tot_prec_rate',
                           'tqv', 'tqv_dia', 'tqc_dia', 'tqi_dia', 'umfl_s', 'vmfl_s', 'sp_10m', 't_2m',
                           'sob_t', 'sod_t', 'sou_t', 'thb_t', 'sob_s', 'sou_s', 'thb_s', 'shfl_s', 'lhfl_s',
                           'snow_con_rate', 'snow_gsp_rate', 'ice_gsp_rate', 'qifl_s', 'qhfl_s',
                           't_seasfc', 'fr_land', 'fr_seaice', 'condhf_ice', 'meltpot_ice', 't_ice', 'h_ice',
                           'albvisdif', 'albvisdir', 'albnirdif', 'albnirdir'
/
EOF
fi

#  add native high-frequency time mean output 3-dim averaged:
if [[ "$output_atm_hfreq" == "yes" ]]; then

cat >> ${atm_namelist} << EOF
&output_nml
 output_start            = "${start_date}"
 output_end              = "${end_date}"
 output_interval         = "${atm_hfreq_output_interval}"  ! the output interval and
 file_interval           = "${atm_file_interval}"    ! the file interval
 filetype                = 4                         ! output format: 2=GRIB2, 4=NETCDFv2
 dom                     = -1		             
 mode                    =  1                        ! 1: forecast mode (relative t-axis); 2: climate mode
 include_last            = .FALSE.                   ! flag whether to include the last time step
 output_filename         = "${EXPNAME}_atm_hfreq_ml"    ! file name base
 filename_format         = "<output_filename>_<datetime2>"
 output_grid             = .TRUE.                    ! flag whether grid information is added to output.
 remap                   = 0                         ! 1: latlon,  0: native grid
 operation               = "mean"                    ! works on icon grid only (remap=0)
 !ml_varlist              = 'pres', 'geopot', 'temp', 'u', 'v', 'w','rho'
 ml_varlist              = 'pres_sfc', 'pres', 'geopot', 'temp', 'u', 'v', 'w' ! , 'rho'
/
EOF
fi

#  add native time mean output 3-dim averaged over OUTPUT_INTERVAL:
if [[ "$output_atm_3d" == "yes" ]]; then

cat >> ${atm_namelist} << EOF
&output_nml
 output_start            = "${start_date}"
 output_end              = "${end_date}"
 output_interval         = "${atm_output_interval}"  ! the output interval and
 file_interval           = "${atm_file_interval}"    ! the file interval
 filetype                = 4                         ! output format: 2=GRIB2, 4=NETCDFv2
 dom                     = -1		             
 mode                    =  1                        ! 1: forecast mode (relative t-axis); 2: climate mode
 include_last            = .FALSE.                   ! flag whether to include the last time step
 output_filename         = "${EXPNAME}_atm_3d_ml"    ! file name base
 filename_format         = "<output_filename>_<datetime2>"
 output_grid             = .TRUE.                    ! flag whether grid information is added to output.
 remap                   = 0                         ! 1: latlon,  0: native grid
 operation               = "mean"                    ! works on icon grid only (remap=0)
 !ml_varlist              = 'pres', 'geopot', 'temp', 'u', 'v', 'qv', 'rh', 'clc', 'tot_qc_dia', 'tot_qi_dia'
 ml_varlist              = 'pres', 'geopot', 'temp', 'u', 'v', 'w','qv', 'rh', 'clc', 'tot_qc_dia', 'tot_qi_dia', 'runoff_s','runoff_g'
/
EOF
fi

#  add interpolated lat-lon output 2d and 3d, no time average:
if [[ "$output_atm_latlon" == "yes" ]]; then

cat >> ${atm_namelist} << EOF
&output_nml       !! interpolated lat-lon output
 output_start            = "${start_date}"
 output_end              = "${end_date}"
 output_interval         = "${atm_output_interval}"  ! the output interval and
 file_interval           = "${atm_file_interval}"    ! the file interval
 filetype                = 4                         ! output format: 2=GRIB2, 4=NETCDFv2
 dom                     = -1
 mode                    = 1                         ! 1: forecast mode (relative t-axis)
 include_last            = .FALSE.                   ! set to false for asynchron output
 output_filename         = "${EXPNAME}_atm_latlon"   ! file name base
 filename_format         = "<output_filename>_<levtype>_<datetime2>"
 output_grid             = .TRUE.                    ! flag whether grid information is added to output.
 remap                   = 1                         ! 1: latlon,  0: native grid
 reg_lon_def             = 0.,1.,360.
 reg_lat_def             = -90.,1.,90.
 ml_varlist              = 'clct', 'tqv', 'tqc_dia', 'tqi_dia', 'sp_10m', 't_2m' ,'t_g', 'qv_2m', 'h_ice', 't_ice',
                           'accthb_s','accthb_t','accsob_s','accsob_t','accshfl_s','acclhfl_s','accumfl_s','accvmfl_s',
                           'pres_sfc', 'tot_prec', 't_seasfc', 'fr_seaice',
                           'fr_land', 'fr_lake', 'fr_seaice', 't_seasfc'
 !hl_varlist              = 'temp', 'u'
 !h_levels                = 10, 500, 5000 
 !m_levels                = "5...(nlev+1)"
/
EOF
fi

#  add native time mean output (debug), averaged over OUTPUT_INTERVAL:
if [[ "$output_atm_icon" == "yes" ]]; then

cat >> ${atm_namelist} << EOF
&output_nml
 output_start            = "${start_date}"
 output_end              = "${end_date}"
 output_interval         = "${atm_output_interval}"  ! the output interval and
 file_interval           = "${atm_file_interval}"    ! the file interval
 filetype                = 4                         ! output format: 2=GRIB2, 4=NETCDFv2
 dom                     = -1		             
 mode                    = 1                         ! 1: forecast mode (relative t-axis)
 include_last            = .FALSE.                   ! set to false for asynchron output
 output_filename         = "${EXPNAME}_atm_icon"     ! file name base
 filename_format         = "<output_filename>_<datetime2>"
 output_grid             = .TRUE.                    ! flag whether grid information is added to output.
 remap                   = 0                         ! 1: latlon,  0: native grid
 operation               = "mean"                    ! works on icon grid only (remap=0)
 ml_varlist              = 'pres_sfc', 'tot_prec_rate', 'sp_10m', 't_2m', 't_g', 'tqv', 'clct', 'h_ice', 't_ice',
                           'shfl_s', 'lhfl_s', 'thb_s', 'sob_s','condhf_ice' 
 !                         'shfl_s_t_7', 'shfl_s_t_9', 'lhfl_s_t_7', 'lhfl_s_t_9',
 !                         'thb_s_t_7', 'thb_s_t_9', 'sob_s_t_7', 'sob_s_t_9',
 !                         'frac_t_7', 'frac_t_8', 'frac_t_9'
/
EOF
fi

#  add native spot value (debug) output 2d and 3d
if [[ "$output_atm_spot" == "yes" ]]; then

cat >> ${atm_namelist} << EOF
&output_nml
 output_start            = "${start_date}"
 output_end              = "${end_date}"
 output_interval         = "${atm_output_interval}"  ! the output interval and
 file_interval           = "${atm_file_interval}"    ! the file interval
 filetype                = 4                         ! output format: 2=GRIB2, 4=NETCDFv2
 dom                     = -1		             
 mode                    = 1                         ! 1: forecast mode (relative t-axis)
 include_last            = .FALSE.                   ! set to false for asynchron output
 output_filename         = "${EXPNAME}_atm_spot"     ! file name base
 filename_format         = "<output_filename>_<datetime2>"
 output_grid             = .TRUE.                    ! flag whether grid information is added to output.
 remap                   = 0                         ! 1: latlon,  0: native grid
 !operation               = "mean"                    ! works on icon grid only (remap=0)
 ml_varlist              = 'pres_sfc', 'tot_prec_rate', 'sp_10m', 't_2m', 't_g', 'tqv', 'clct', 'h_ice', 't_ice',
                           'shfl_s', 'lhfl_s', 'thb_s', 'sob_s','condhf_ice',
                           'fr_land', 'fr_lake', 'fr_seaice', 't_seasfc', 'lsm_switch', 'lsm_ctr_c', 'topography_c'
 !                         'shfl_s_t_7', 'shfl_s_t_9', 'lhfl_s_t_7', 'lhfl_s_t_9',
 !                         'thb_s_t_7', 'thb_s_t_9', 'sob_s_t_7', 'sob_s_t_9',
 !                         'condhf_ice', 'frac_t_7', 'frac_t_8', 'frac_t_9',
/
EOF
fi

#  output jsb_2d
if [[ "$output_jsb_2d" == "yes" ]]; then

cat >> ${atm_namelist} << EOF
&output_nml
 output_start            = "${start_date}"
 output_end              = "${end_date}"
 output_interval         = "${atm_output_interval}"  ! the output interval and
 file_interval           = "${atm_file_interval}"    ! the file interval
 filetype                = 4                         ! output format: 2=GRIB2, 4=NETCDFv2
 dom                     = -1		             
 mode                    =  1                        ! 1: forecast mode (relative t-axis); 2: climate mode
 include_last            = .FALSE.                   ! flag whether to include the last time step
 output_filename         = "${EXPNAME}_jsb_2d"       ! file name base
 filename_format         = "<output_filename>_<datetime2>"
 output_grid             = .TRUE.                    ! flag whether grid information is added to output.
 remap                   = 0                         ! 1: latlon,  0: native grid
 operation               = "mean"                    ! works on icon grid only (remap=0)
 ! ml_varlist = 'group:jsb_all_basic'
   ml_varlist = 'group:jsb_seb_basic','group:jsb_hydro_basic','group:jsb_sse_basic',
                'group:jsb_pheno_basic','group:jsb_rad_basic'
/
EOF
fi

if [[ ${output_lnd_mon} == yes ]]; then
  cat >> ${atm_namelist} << EOF
&output_nml ! 'lnd_mon'
 output_start            = "${start_date}"
 output_end              = "${end_date}"
 output_interval         = "${atm_output_interval}"  ! the output interval and
 file_interval           = "${atm_file_interval}"    ! the file interval
 filetype                = 4                         ! output format: 2=GRIB2, 4=NETCDFv2
 dom                     = -1		             
 mode                    =  1                        ! 1: forecast mode (relative t-axis); 2: climate mode
 include_last            = .FALSE.                   ! flag whether to include the last time step
 output_filename         = "${EXPNAME}_lnd_mon"      ! file name base
 filename_format         = "<output_filename>_<datetime2>"
 output_grid             = .TRUE.                    ! flag whether grid information is added to output.
 remap                   = 0                         ! 1: latlon,  0: native grid
 operation               = "mean"                    ! works on icon grid only (remap=0)
  ! ml_varlist = 'hd_water_error_gsum_box',
    ml_varlist = 'hydro_trans_gmean_box', 'hydro_evapotrans_gmean_box',
                 'hydro_weq_land_gsum_box', 'hydro_discharge_ocean_gsum_box',
                 'hydro_wtr_rootzone_rel_gmean_box',
                 'hydro_fract_snow_gsum_box', 'hydro_weq_snow_gsum_box',
                 'hydro_weq_balance_err_gsum_box', 'pheno_lai_ta_gmean_box',
                 'pheno_fract_fpc_gmean_box', 'seb_t_gmean_box'
/

EOF
fi

#  output lnd_dbg
if [[ "$output_lnd_dbg" == "yes" ]]; then

cat >> ${atm_namelist} << EOF
&output_nml
 output_start            = "${start_date}"
 output_end              = "${end_date}"
 output_interval         = "${atm_output_interval}"  ! the output interval and
 file_interval           = "${atm_file_interval}"    ! the file interval
 filetype                = 4                         ! output format: 2=GRIB2, 4=NETCDFv2
 dom                     = -1		             
 mode                    =  1                        ! 1: forecast mode (relative t-axis); 2: climate mode
 include_last            = .FALSE.                   ! flag whether to include the last time step
 output_filename         = "${EXPNAME}_lnd_dbg"      ! file name base
 filename_format         = "<output_filename>_<datetime2>"
 output_grid             = .TRUE.                    ! flag whether grid information is added to output.
 remap                   = 0                         ! 1: latlon,  0: native grid
 !operation               = "mean"                    ! works on icon grid only (remap=0)
 ml_varlist              = 'u', 'v', 'w', 'temp', 'theta_v', 'exner', 'pres', 'pres_msl', 'rho', 'rho_ic',
                           'group:precip_vars', 'group:additional_precip_vars', 'clc',
                           'group:land_vars', 'group:rad_vars', 'group:dwd_fg_sfc_vars',
                           'group:vdiff', 'group:vdiff-sft', 'clct', 'tot_prec_rate',
                           'tqv', 'tqc', 'tqi', 'tqr', 'tqs', 'total_water_var',
                           'qv', 'qc', 'gust10', 'rcld', 'ddt_temp_turb',
                           't_2m', 'tmin_2m', 'tmax_2m', 'td_2m', 'z_ifc', 'z_mc',
                           'tqv_dia', 'tqc_dia', 'tqi_dia', 'umfl_s', 'vmfl_s', 'sp_10m', 't_2m',
                           'sob_t', 'thb_t', 'sob_s', 'thb_s', 'shfl_s', 'lhfl_s', 'qhfl_s', 't_seasfc', 'fr_seaice'
/
EOF
fi

#  instantaneous output of water content box:
output_lnd_wat='no'
if [[ "$output_lnd_wat" == "yes" ]]; then
cat >> ${atm_namelist} << EOF
&output_nml
 output_start            = "${start_date}"
 output_end              = "${end_date}"
 output_interval         = "${atm_output_interval}"  ! the output interval and
 file_interval           = "${atm_file_interval}"    ! the file interval
 filetype                = 4                         ! output format: 2=GRIB2, 4=NETCDFv2
 dom                     = -1		             
 mode                    =  1                        ! 1: forecast mode (relative t-axis); 2: climate mode
 include_last            = .FALSE.                   ! flag whether to include the last time step
 output_filename         = "${EXPNAME}_jsb_wbal"     ! file name base
 filename_format         = "<output_filename>_<datetime2>"
 output_grid             = .TRUE.                    ! flag whether grid information is added to output.
 remap                   = 0                         ! 1: latlon,  0: native grid
 !operation               = "mean"                    ! works on icon grid only (remap=0)
 !ml_varlist              = 'hydro_water_content_box'
 ml_varlist              = 'hydro_weq_fluxes_box', 'hydro_weq_land_box', 'hydro_weq_balance_err_box',
                           'hydro_runoff_box'   , 'hydro_drainage_box',
                           'hd_water_budget_box', 'hd_local_wbal_error_box'
/
EOF
fi

# additional output of atmosphere albedo: albnir
output_atm_alb='no'
if [[ "$output_atm_alb" == "yes" ]]; then
cat >> ${atm_namelist} << EOF
&output_nml
 output_start            = "${start_date}"
 output_end              = "${end_date}"
 output_interval         = "${atm_output_interval}"  ! the output interval and
 file_interval           = "${atm_file_interval}"    ! the file interval
 filetype                = 4                         ! output format: 2=GRIB2, 4=NETCDFv2
 dom                     = -1		             
 mode                    =  1                        ! 1: forecast mode (relative t-axis); 2: climate mode
 include_last            = .FALSE.                   ! flag whether to include the last time step
 output_filename         = "${EXPNAME}_atm_alb"      ! file name base
 filename_format         = "<output_filename>_<datetime2>"
 output_grid             = .TRUE.                    ! flag whether grid information is added to output.
 remap                   = 0                         ! 1: latlon,  0: native grid
 !operation               = "mean"                    ! works on icon grid only (remap=0)
 ml_varlist              = 'albvisdif', 'albvisdir', 'albnirdif', 'albnirdir', 'albdif'
/
EOF
fi

cat >> ${atm_namelist} << EOF
&dbg_index_nml
  idbg_mxmn              = 1                          ! initialize MIN/MAX  debug output
  idbg_val               = 0                          ! initialize one cell debug output
  idbg_slev              = 1                          ! initialize start level for debug output
  idbg_elev              = 3                          ! initialize start level for debug output
/
&extpar_nml
 itopo                   = 1
 n_iter_smooth_topo      = 1
 heightdiff_threshold    = 3000.
/
&lnd_nml
 nlev_snow               = 3
 lmulti_snow             = .false.
 itype_heatcond          = 3
 idiag_snowfrac          = 20
 lsnowtile               = .true.
 llake                   = .true.
 itype_lndtbl            = 4
 itype_evsl              = 4
 itype_trvg              = 3
 itype_root              = 2
 cwimax_ml               = 5.e-4
 c_soil                  = 1.25
 c_soil_urb              = 0.5
 itype_snowevap          = 2
 lprog_albsi             = .true.      ! default = F 
 lseaice                 = .true.
 hice_min                = 0.05        ! default of nwp sea-ice model - 0.05 in sea-ice model of icon-o
 hice_max                = 10.0        ! must correspont to seaice_limit in icon-o in % of upper layer thickness
 sstice_mode             = 1           ! 1 for coupled 
 !                                     ! parameters for jsbach land model:
 ntiles                  = 1           ! 1 for jsbach, 3 for terra?
/
&turb_vdiff_nml
 fsl                     = 0.8         ! for lowest model layer thickness of 20m
 pr0                     = 0.68   !0.85! default: 0.68; neutral limit Prandtl number (0.6 to 1.0)
 f_theta_limit_fraction  = 0.15
 f_theta_decay           = 4.0         ! default: 4.0
 ek_ep_ratio_stable      = 2.33        ! default: 3 - Mauritzen: 1/(0.3 +- 0.1) -1 = 1.5 to 4
 ek_ep_ratio_unstable    = 1.0         ! default: 2 - Mauritzen: 1
/
&radiation_nml
 isolrad                 = 2
 irad_o3                 = 5  ! slo use 79 
 irad_aero               = 18 !slo use 12

 ghg_filename            = './bc_greenhouse_gases.nc'
 irad_co2                = 4           ! 4: from greenhouse gas scenario
 irad_ch4                = 4           ! 4: from greenhouse gas scenario
 irad_n2o                = 4           ! 4: from greenhouse gas scenario
 irad_cfc11              = 4           ! 4: from greenhouse gas scenario
 irad_cfc12              = 4           ! 4: from greenhouse gas scenario

 izenith                 = 4           ! 4: NWP default, 3: no annual cycle
 albedo_type             = 1           ! Modis albedo
 direct_albedo           = 4
 direct_albedo_water     = 3
 albedo_whitecap         = 1
 ecrad_llw_cloud_scat    = .true.
 ecRad_data_path         = '${ecRad_data_path}' 
 !decorr_pole             =  750        ! default: 2000
 !decorr_equator          = 2900        ! default: 2000
/
&ccycle_nml
  ccycle_config%iccycle  = 2            ! 0: vmr_co2=384 for jsbach (def); 2: ccycle namelist values used
  ccycle_config%ico2conc = 2            ! 2: use vmr_co2 of ccycle; 4: use values of GHG file
  ccycle_config%vmr_co2  = 312.82e-06   ! same value as in radiation_nml
/
EOF

# cat namelist
cat $atm_namelist

#
#-----------------------------------------------------------------------------
# add standard atmo_non-hydrostatic_files
. ${thisdir}/add_required_atmo_non-hydrostatic_files


#-----------------------------------------------------------------------------
# III. ICON OCEAN and SEA-ICE
#-----------------------------------------------------------------------------

# MPI ocean grid files
#ocean_grid_folder="${icon_data_poolFolder}/mpim/$ocean_gridID"
#ocean_grid_target="icon_grid_${ocean_gridID}_R02B06_O.nc"
ocean_grid_folder="$SetupXPP"
ocean_grid_target="icon_grid_0035_modsills_R02B06_O.nc"

# ----------------------------------------------------------------------------
#
# ocean namelist
# --------------

#-----------------------------------------------------------------------------
#set the vertical coordinate  : 0=zlev, 1=zstar

VERT_COR=1
minVerticalLevels=2
if [ ${VERT_COR} = 0 ] ; then
  vert_cor_type=0
  select_lhs=2
  l_lhs_direct=.true.
  STRETCH_C=''
  limitice=0.8                #  12m mixed layer depth assumed, i.e. 80% maximum sea-ice depth
else
  vert_cor_type=1
  select_lhs=1
  l_lhs_direct=.false.
  STRETCH_C=",'stretch_c'"    #  output of variable thicknes
  limitice=5.0                #  2m upper layer depth assumed, i.e. 10m maximum sea-ice depth
fi

#-----------------------------------------------------------------------------
#set the vertical number of levels

LEV=L72
if [ ${LEV} == L40 ] ; then 

    n_zlev=40
    dzlev_m="12.,10.,10.,10.,10.,10.,13.,15.,20.,25.,30.,35.,40.,45.,50.,55.,60.,70.,80.,90.,
         100.,110.,120.,130.,140.,150.,170.,180.,190.,200.,220.,250.,270.,300.,350.,400.,
         450.,500.,500.,600."

    levidx_100m=9
    levidx_200m=12
    levidx_2000m=30

    minVerticalLevels=2

elif [ ${LEV} == L64 ] ; then

    n_zlev=64
    dzlev_m="12.,10.,10.,10.,10.,10.,10.,10.,10.,10.,11.,12.,13.,14.,15.,16.,17.,18.,20.,22.,
         24.,26.,28.,30.,32.,35.,38.,41.,45.,49.,53.,58.,62.,66.,71.,75.,80.,85.,91.,97.,
         104.,111.,118.,125.,132.,138.,145.,152.,160.,167.,175.,182.,188.,195.,201.,208.,
         213.,219.,224.,230.,235.,241.,250.,260."

    levidx_100m=10
    levidx_200m=17
    levidx_2000m=46

    minVerticalLevels=2

elif [ ${LEV} == L72 ] ; then

    n_zlev=72
    dzlev_m="2.0,2.2,2.5,2.8,3.1,3.5,3.9,4.4,4.9,5.4,5.9,6.4,7.1,7.7,8.4,9.2,10.1,11.0,
           12.0,13.2,14.4,15.7,17.1,18.7,20.4,22.3,24.3,26.5,28.9,31.5,34.3,37.3,40.6,
           43.1,45.3,46.8,48.4,50.0,51.7,53.4,55.2,57.0,58.9,60.8,62.9,66.6,72.6,80.6,
           90.6,100.2,110.0,120.3,128.7,137.4,146.4,155.7,165.2,174.8,184.4,194.1,203.6,
           212.9,221.9,230.5,238.5,245.9,252.4,258.1,262.8,266.4,268.9,270.1"

    levidx_100m=18
    levidx_200m=25
    levidx_2000m=55

    minVerticalLevels=10

elif [ ${LEV} == L128 ] ; then

    n_zlev=128
    dzlev_m="11.0,   9.0,     8.0,   8.0,     8.0,    8.0,    8.0,    8.0,    8.0,    8.0,\
              8.0,    8.0,    8.0,    8.25,   8.5,    8.75,   9.0,   9.25,    9.5,   9.75,\
             10.0,   10.0,   10.0,   10.0,   10.0,   10.0,   10.0,   10.0,   10.0,   10.0,\
             10.5,   11.0,   11.5,   12.0,   12.5,   13.0,   13.5,   14.0,   14.5,   15.0,\
             15.5,   16.0,   16.5,   17.0,   17.5,   18.0,   18.5,   19.0,   19.5,   20.0,\
             20.5,   21.0,   21.5,   22.0,   22.5,   23.0,   23.5,   24.0,   24.5,   25.0,\
             25.5,   26.0,   26.5,   27.0,   28.5,   29.0,   29.5,   30.0,   30.5,   31.0,\
             31.0,   32.0,   33.0,   34.0,   35.0,   36.0,   37.0,   38.0,   39.0,   40.0,\
             42.0,   44.0,   46.0,   48.0,   50.0,   52.0,   54.0,   56.0,   58.0,   60.0,\
             62.0,   64.0,   66.0,   68.0,   70.0,   72.0,   74.0,   76.0,   78.0,   80.0,\
             82.0,   84.0,   86.0,   88.0,   90.0,   92.0,   94.0,   96.0,   98.0,  100.0,\
            102.0,  104.0,  106.0,  108.0,  110.0,  112.0,  114.0,  116.0,  118.0,  200.0,\
            200.0,  200.0,  200.0,  200.0,  200.0,  200.0,  200.0,  200.0"

    levidx_100m=14
    levidx_200m=24
    levidx_2000m=92

    minVerticalLevels=2

elif [ ${LEV} == L128SMT ] ; then

    n_zlev=128
    dzlev_m="2.0, 2.1, 2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8, 3.0, 3.1, 3.2,\
                 3.4, 3.5, 3.7, 3.9, 4.0, 4.2, 4.4, 4.6, 4.8, 5.0, 5.3, 5.5,\
                 5.8, 6.0, 6.3, 6.6, 6.9, 7.2, 7.5, 7.8, 8.2, 8.5, 8.9, 9.3,\
                 9.8, 10.2, 10.7, 11.1, 11.5, 11.9, 12.3, 12.7, 13.1, 13.5,\
                14.0, 14.5, 14.9, 15.4, 15.9, 16.5, 17.0, 17.6, 18.2, 18.8,\
                19.4, 20.0, 20.7, 21.4, 22.1, 22.8, 23.6, 24.4, 25.2, 26.0,\
                26.9, 27.8, 28.7, 29.7, 30.6, 31.7, 32.7, 33.8, 34.9, 36.1,\
                37.3, 38.5, 39.8, 41.1, 42.5, 43.9, 45.3, 46.8, 48.4, 50.0,\
                51.7, 53.4, 55.2, 57.0, 58.9, 60.8, 62.9, 64.9, 67.1, 69.3,\
                71.6, 74.0, 76.5, 79.0, 81.6, 84.3, 87.1, 90.0, 93.0, 96.1,\
                99.3, 102.6, 106.0, 109.5, 113.2, 116.9, 120.8, 124.8, 128.9,\
               133.2, 137.6, 142.2, 146.9, 151.8, 156.9, 162.1, 167.4, 173.0,\
               178.7, 184.7, 190.8, 197.1"

    levidx_100m=27
    levidx_200m=37
    levidx_2000m=96

    minVerticalLevels=12
    
fi

#-----------------------------------------------------------------------------
# HAMOCC
#

use_hamocc=no  
ocean_vertical_levels=$LEV

if [  "x${use_hamocc}"  = "xyes" ]; then
lhamocc=".TRUE."
lbgcadv=".TRUE."
nlev_eu=$ocean_vertical_levels
# set nlev_eu to level belonging to approx 500m
if [ "x$ocean_vertical_levels" = "x40" ];then
nlev_eu=19
fi
if [ "x$ocean_vertical_levels" = "x64" ];then
nlev_eu=26
fi
if [ "x$ocean_vertical_levels" = "x20" ];then
nlev_eu=16
fi
else
lhamocc=".FALSE."
lbgcadv=".FALSE."
fi
#l_init_bgc=".false." # Hamocc state variables are in restart
#if [[ "$initialiseOcean" == "fromRestart" ]] || [[ "$initialiseOcean" == "fromClimatology" ]]; then
#  l_init_bgc=".true." # initialize HAMOCC (HAMOCC state variables are not in restart)
#fi
# ----------------------------------------------------------------------------
#
# ocean namelist
# --------------

cat > ${oce_namelist} << EOF
!
&coupling_mode_nml
  coupled_to_atmo            = .TRUE.
/
&parallel_nml
 nproma                      = ${nproma_oce}
 num_io_procs                = ${mpi_oce_io_procs}
 pio_type                    = 1                                ! default 1: asynchron io
 num_restart_procs           = ${num_rest_oce_mpi}              ! number of procs for multifile restart
 num_prefetch_proc           = 0
 p_test_run                  = .FALSE.
 l_fast_sum                  = .FALSE.
/
&grid_nml
 dynamics_grid_filename      = "${ocean_grid_target}"
 use_dummy_cell_closure      = .TRUE.
 use_duplicated_connectivity = .FALSE.
/
&dynamics_nml
 iequations                  = -1                               ! -1: hydrost. ocean model
/
&run_nml
 modelTimeStep               = "${oceTimeStep}"
 output                      = 'nml'                            ! namelist controlled output scheme
 activate_sync_timers        = .TRUE.
 profiling_output            = 1                                ! aggregated: 1; detailed: 2; in files: 3
 msg_timestamp               = .FALSE.
 timers_level                = 10
 debug_check_level           = 1
 Restart_filename            = "${EXPNAME}_restart_oce_<rsttime>.nc"
/
EOF
# output of fixed geometry
cat >> ${oce_namelist} << EOF
 &output_nml
  filetype         =  5                               ! output format: 2=GRIB2, 4=NETCDFv2, 5=NETCDFv4
  output_filename  = "${EXPNAME}_oce_fx"
  filename_format  = "<output_filename>_<datetime2>"
  output_start     = "${start_fx}"                    ! start date in ISO-format
  output_end       = "${start_fx}"                    ! end date in ISO-format
  output_interval  = "${oce_output_interval}"         ! interval in ISO-format
  file_interval    = "${oce_file_interval}"           ! interval in ISO-format
  output_grid      = .TRUE.
  mode             =  1                               ! 1: forecast mode (relative t-axis); 2: climate mode
  include_last     = .FALSE.
  !ml_varlist       =  'wet_c','basin_c','regio_c','lsm_ctr_c'
  ml_varlist       = 'lsm_ctr_c','lsm_c','lsm_e','surface_cell_sea_land_mask','surface_edge_sea_land_mask',
                     'surface_vertex_sea_land_mask','vertex_bottomLevel','basin_c','regio_c','bottom_thick_c',
                     'bottom_thick_e','column_thick_c','column_thick_e','wet_c','wet_e','wet_halo_zero_c',
                     'wet_halo_zero_e','prism_thick_c','invConstantPrismThickness','prism_volume','prism_thick_e',
                     'prism_thick_flat_sfc_c','prism_thick_flat_sfc_e','inverse prism_thick_c','prism_center_dist_c',
                     'constantPrismCenters_Zdistance','constantPrismCenters_invZdistance','inv_prism_thick_e',
                     'inv_prism_center_dist_c','inv_prism_center_dist_e','depth_CellMiddle'
/
EOF
#
if [[ "$output_oce_def" == "yes" ]]; then
   #
   cat >> ${oce_namelist} << EOF
&output_nml
  filetype                   = 5
  output_filename            = "${EXPNAME}_oce_def"
  filename_format            = "<output_filename>_<datetime2>"
  output_start               = "${start_date}"                  ! start in ISO-format
  output_end                 = "${end_date}"                    ! end in ISO-format
  output_interval            = "${oce_output_interval_def}"     ! interval in ISO-format
  file_interval              = "${oce_file_interval}"
  mode                       = 1                                ! 1: forecast mode (relative t-axis)
                                                                ! 2: climate mode (absolute t-axis)
  include_last               = .FALSE.
  output_grid                = .TRUE.
  operation                  = "mean"
  ml_varlist                 = 'group:oce_default', 'group:oce_essentials'
  !ml_varlist                 = 'group:oce_default', 'group:oce_essentials','A_veloc_v','A_tracer_v_to'
/
EOF
fi

if [[ "$output_oce_ice" == "yes" ]]; then
  cat >> ${oce_namelist} <<EOF

&output_nml
  output_start     = "${start_date}"                  ! start date in ISO-format
  output_end       = "${end_date}"                    ! end date in ISO-format
  output_interval  = "${oce_output_interval}"         ! interval in ISO-format
  file_interval    = "${oce_file_interval}"           ! interval in ISO-format
  mode             =  1                               ! 1: forecast mode (relative t-axis), 2: climate mode (absolute t-axis)
  operation        = 'mean'                           ! mean over output interval
  include_last     = .FALSE.                          ! set to false for asynchron output
  output_grid      = .TRUE.
  output_filename  = "${EXPNAME}_oce_ice"
  filename_format  = "<output_filename>_<datetime2>"
  filetype         =  5                               ! output format: 2=GRIB2, 4=NETCDFv2, 5=NETCDFv4
  !m_levels         = "1...9,23,30,34"                 ! surface and some subsurface levels only
  !ml_varlist       =  draftave, hi, hs, conc, to, so, mld, Qtop, Qbot, u, v, condep ${STRETCH_C}
  m_levels         = "1...10,${levidx_100m},${levidx_200m},${levidx_2000m}"  ! surface and 200, 1000, 2000m levels only
  ml_varlist       =  'draftave','hi','hs','conc','verticallyTotal_mass_flux_e','ice_u','ice_v',
                      'to','so', 'mlotst', 'zos', 'Qtop', 'Qbot', 'u', 'v', 'condep' ${STRETCH_C}
/
EOF
fi

if [[ "$output_oce_qps" == "yes" ]]; then
  cat >> ${oce_namelist} <<EOF

&output_nml
  output_start     = "${start_date}"                  ! start date in ISO-format
  output_end       = "${end_date}"                    ! end date in ISO-format
  output_interval  = "P1M"         ! interval in ISO-format
  file_interval    = "P50Y"           ! interval in ISO-format
  mode             =  1                               ! 1: forecast mode (relative t-axis), 2: climate mode (absolute t-axis)
  operation        = 'mean'                           ! mean over output interval
  include_last     = .FALSE.                          ! set to false for asynchron output
  output_grid      = .TRUE.
  output_filename  = "${EXPNAME}_oce_qps"
  filename_format  = "<output_filename>_<datetime2>"
  filetype         =  5                               ! output format: 2=GRIB2, 4=NETCDFv2, 5=NETCDFv4
  ml_varlist       = 'to', 'so', 'tke', 'u', 'v', 'w_deriv', 'zos', 'hi', 'hs',
                     'conc', 'mlotst', 'verticallyTotal_mass_flux_e', 'ice_u',
                     'ice_v', 'zos_square', 'HeatFlux_Total', 'FrshFlux_Runoff',
                     'FrshFlux_Precipitation', 'FrshFlux_Evaporation',
                     'FrshFlux_TotalOcean', 'FrshFlux_VolumeIce', 'totalsnowfall',
                     'FrshFlux_VolumeTotal', 'group:ocean_moc'
/
EOF
fi

if [[ "$output_oce_tke" == "yes" ]]; then
  cat >> ${oce_namelist} <<EOF

&output_nml
  output_start     = "${start_date}"                  ! start date in ISO-format
  output_end       = "${end_date}"                    ! end date in ISO-format
  output_interval  = "P1M"         ! interval in ISO-format
  file_interval    = "P50Y"           ! interval in ISO-format
  mode             =  1                               ! 1: forecast mode (relative t-axis), 2: climate mode (absolute t-axis)
  operation        = 'mean'                           ! mean over output interval
  include_last     = .FALSE.                          ! set to false for asynchron output
  output_grid      = .TRUE.
  output_filename  = "${EXPNAME}_oce_tke"
  filename_format  = "<output_filename>_<datetime2>"
  filetype         =  5                               ! output format: 2=GRIB2, 4=NETCDFv2, 5=NETCDFv4
  ml_varlist       = 'group:oce_vmix_tke','A_tracer_v_to','A_veloc_v'
/
EOF
fi


if [[ "$output_oce_kin" == "yes" ]]; then
  cat >> ${oce_namelist} <<EOF

&output_nml
  output_start     = "${start_date}"                  ! start date in ISO-format
  output_end       = "${end_date}"                    ! end date in ISO-format
  output_interval  = "P1D"         ! interval in ISO-format
  file_interval    = "P50Y"           ! interval in ISO-format
  mode             =  1                               ! 1: forecast mode (relative t-axis), 2: climate mode (absolute t-axis)
!  operation        = 'mean'                           ! mean over output interval
  include_last     = .FALSE.                          ! set to false for asynchron output
  output_grid      = .TRUE.
  output_filename  = "${EXPNAME}_oce_kin"
  filename_format  = "<output_filename>_<datetime2>"
  filetype         =  5                               ! output format: 2=GRIB2, 4=NETCDFv2, 5=NETCDFv4
  m_levels = "1,25,55"
!  ml_varlist = zos, mlotst, hi, hs, conc, ice_u, ice_v, u, v, to, so, kin, vort
  ml_varlist = hflcorr_lw
/
EOF
fi


#
if [[ "$output_oce_mon" == "yes" ]]; then
   #
   cat >> ${oce_namelist} << EOF
&output_nml
  filetype                   = 4
  output_filename            = "${EXPNAME}_oce_mon"
  filename_format            = "<output_filename>_<datetime2>"
  output_start               = "${start_date}"                  ! start in ISO-format
  output_end                 = "${end_date}"                    ! end in ISO-format
  !output_interval            = "${mon_output_interval}"
  output_interval            = "${oce_output_interval}"
  file_interval              = "${oce_file_interval}"
  mode                       = 1                                ! 1: forecast mode (relative t-axis)
                                                                ! 2: climate mode (absolute t-axis)
  include_last               = .FALSE.
  output_grid                = .FALSE.
  operation                  = "mean"
  ml_varlist                 = 'group:ocean_monitor'
/
EOF
fi
#
if [[ "$output_oce_moc" == "yes" ]]; then
   #
   cat >> ${oce_namelist} << EOF
&output_nml
  filetype                   = 5
  output_filename            = "${EXPNAME}_oce_moc"
  filename_format            = "<output_filename>_<datetime2>"
  output_start               = "${start_date}"                  ! start in ISO-format
  output_end                 = "${end_date}"                    ! end in ISO-format
  output_interval            = "${oce_output_interval}"
  file_interval              = "${oce_file_interval}"
  mode                       = 1                                ! 1: forecast mode (relative t-axis)
                                                                ! 2: climate mode (absolute t-axis)
  include_last               = .FALSE.
  output_grid                = .FALSE.
  operation                  = "mean"
  ml_varlist                 = 'group:ocean_moc'
/
EOF
fi

if [[ "$output_oce_flx" == "yes" ]]; then
  cat >> ${oce_namelist} <<EOF

&output_nml
  filetype         =  5                               ! output format: 2=GRIB2, 4=NETCDFv2, 5=NETCDFv4
  output_filename  = "${EXPNAME}_oce_flx"
  filename_format  = "<output_filename>_<datetime2>"
  output_start     = "${start_date}"                  ! start date in ISO-format
  output_end       = "${end_date}"                    ! end date in ISO-format
  output_interval  = "P1D"         ! interval in ISO-format
  file_interval    = "${oce_file_interval}"           ! interval in ISO-format
  output_grid      = .TRUE.
  mode             =  1                               ! 1: forecast mode (relative t-axis); 2: climate mode
  operation        = 'mean'                           ! mean over output interval
  include_last     = .FALSE.
  m_levels         = "1"                            ! surface and subsurface level only
  ml_varlist       =  'Qtop', 'Qbot','HeatFlux_Total','HeatFlux_ShortWave','HeatFlux_LongWave','HeatFlux_Sensible','HeatFlux_Latent',
                      'FrshFlux_Runoff','FrshFlux_Precipitation','FrshFlux_Evaporation','FrshFlux_SnowFall','FrshFlux_TotalOcean',
                      'FrshFlux_VolumeIce','totalsnowfall','atmos_fluxes_stress_x','atmos_fluxes_stress_y','atmos_fluxes_stress_xw','atmos_fluxes_stress_yw'
 !                     'sea_level_pressure', 'hfl_nudge', 'sst_target', 'to'
 !                     'hflcorr_lw', 'hflcorr_net'

/
EOF
fi

if [[ "$output_oce_dbg" == "yes" ]]; then
  cat >> ${oce_namelist} <<EOF

&output_nml
  filetype         =  5                               ! output format: 2=GRIB2, 4=NETCDFv2, 5=NETCDFv4
  output_filename  = "${EXPNAME}_oce_dbg"
  filename_format  = "<output_filename>_<datetime2>"
  output_start     = "${start_date}"                  ! start date in ISO-format
  output_end       = "${end_date}"                    ! end date in ISO-format
  output_interval  = "${oce_output_interval}"         ! interval in ISO-format
  file_interval    = "${oce_file_interval}"           ! interval in ISO-format
  output_grid      = .TRUE.
  mode             =  1                               ! 1: forecast mode (relative t-axis); 2: climate mode
  operation        = 'mean'                           ! mean over output interval
  include_last     = .FALSE.
  m_levels         = "1,2"                            ! surface and subsurface level only
  ml_varlist       =  'Qtop', 'Qbot','Qbot_slow', 'zHeatOceI','heatOceI','heatOceW','draftave','zUnderIce',
                      'mld','condep','zos','u_vint','hi','hs','conc','to','so','u',
                      'HeatFlux_Total','atmos_fluxes_HeatFlux_ShortWave','atmos_fluxes_HeatFlux_LongWave',
                      'HeatFlux_ShortWave','HeatFlux_LongWave','HeatFlux_Sensible','HeatFlux_Latent',
                      'FrshFlux_Runoff','FrshFlux_Precipitation','FrshFlux_Evaporation','FrshFlux_SnowFall',
                      'FrshFlux_TotalOcean','FrshFlux_VolumeIce','totalsnowfall','Wind_Speed_10m'
/
EOF
fi

#  instantaneous output of sea-level
output_oce_zos='no'
if [[ "$output_oce_zos" == "yes" ]]; then
  cat >> ${oce_namelist} <<EOF
&output_nml
  output_start     = "${start_date}"                  ! start date in ISO-format
  output_end       = "${end_date}"                    ! end date in ISO-format
  output_interval  = "${oce_output_interval}"         ! interval in ISO-format
  file_interval    = "${oce_file_interval}"           ! interval in ISO-format
  mode             =  1                               ! 1: forecast mode (relative t-axis), 2: climate mode (absolute t-axis)
  !operation        = 'mean'                           ! mean over output interval
  include_last     = .FALSE.                          ! set to false for asynchron output
  output_grid      = .TRUE.
  output_filename  = "${EXPNAME}_oce_zos"
  filename_format  = "<output_filename>_<datetime2>"
  filetype         =  5                               ! output format: 2=GRIB2, 4=NETCDFv2, 5=NETCDFv4
  ml_varlist       =  'zos'
/
EOF
fi

#  instantaneous global mean output of sea-level
output_oce_ssh='no'
if [[ "$output_oce_ssh" == "yes" ]]; then
  cat >> ${oce_namelist} <<EOF
&output_nml
  output_start     = "${start_date}"                  ! start date in ISO-format
  output_end       = "${end_date}"                    ! end date in ISO-format
  output_interval  = "${oce_output_interval}"         ! interval in ISO-format
  file_interval    = "${oce_file_interval}"           ! interval in ISO-format
  mode             =  1                               ! 1: forecast mode (relative t-axis), 2: climate mode (absolute t-axis)
  !operation        = 'mean'                           ! mean over output interval
  include_last     = .FALSE.                          ! set to false for asynchron output
  output_grid      = .FALSE.
  output_filename  = "${EXPNAME}_oce_ssh"
  filename_format  = "<output_filename>_<datetime2>"
  filetype         =  4                               ! output format: 2=GRIB2, 4=NETCDFv2, 5=NETCDFv4
  ml_varlist       =  'ssh_global'
/
EOF
fi

##############################################################

cat >> ${oce_namelist} << EOF
&dbg_index_nml
  idbg_mxmn                  = 1                                ! initialize MIN/MAX  debug output
  idbg_val                   = 0                                ! initialize one cell debug output
  idbg_slev                  = 1                                ! initialize start level for debug output
  idbg_elev                  = 3                                ! initialize end level for debug output
  dbg_lat_in                 = 30.0                             ! latitude location of one cell debug output
  dbg_lon_in                 = -30.0                            ! longitude location of one cell debug output
  str_mod_tst                ='oceanCouplng'                    ! define modules to print out in debug mode
  !str_mod_tst                = 'all'                            ! define modules to print out in debug mode
/
&ocean_dynamics_nml
!
! zlev or zstar:
  vert_cor_type = ${vert_cor_type}
  minVerticalLevels = ${minVerticalLevels}

!
! Number of vertical levels
  n_zlev                =  $n_zlev
  dzlev_m(1:${n_zlev})  =  $dzlev_m
!
  l_edge_based                               = .FALSE.     ! edge- or cell-based mimetic discretization
! l_partial_cells                            = .FALSE.     ! partial bottom cells=TRUE: local varying bottom depth
  select_solver                              = 4           ! 1=gmres_oce_old; 2=ocean_restart_gmres, 3=mixed precisison restart
                                                           ! 4=CG (default) 5=CGJ 6=BiCG 7=GMRES restart (legacy) 8=MINRES
  							   ! 40= optimised CG
  use_absolute_solver_tolerance              = .TRUE.
  solver_tolerance                           = 1.0E-8      ! 1e-10 in omip-YVF - enlarged to 1e-9 (LL opt)
  select_lhs                        = ${select_lhs}        ! 1=operator based (default) 2=matrix based - 2=error?
  l_lhs_direct                      = ${l_lhs_direct}      ! .true.= use lhs implementation directly  .false.= matrix scanner (default)
  solver_FirstGuess                          = 2           ! 0=start from zeros 1=last timestep smoothed 2=last timestep (default)

! solver_max_iter_per_restart                = 14
! solver_max_restart_iterations              = 100         ! outer (restart solver)

  fast_performance_level                     = 200         ! performance level 12: for cell-based; 5: default
  use_continuity_correction                  = .TRUE.      ! height adjustment according to vertical velocity in dynamics
  cfl_check                                  = .FALSE.
  cfl_write                                  = .FALSE.

  i_bc_veloc_top                             = 1
  i_bc_veloc_bot                             = 1           ! 0: (def) bottom friction off, 1: on
/
&ocean_tracer_transport_nml
  flux_calculation_horz                      = 5           ! 1=upwind, 2=central, 3=Lax-Friedrichs,
                                                           ! 4=Miura, 5=FCT with Zalesak limiter (default)
  flux_calculation_vert                      = 7           ! 6=adpo; 7=upwind biased ppm (default); 8=FCT with zalesak limiter
  ! define low and high order methods to be used in
  ! horizontal flux corrected transport methods
  ! (flux_calculation_horz=4,5)
  fct_low_order_flux                         = 1           ! horizontal low  order method: 1=upwind (def), no other implemented
  fct_high_order_flux                        = 5           ! horizontal high order method: 1=upwind, 2=central, 3=lax_friedrichs, 4=miura_order1
  fct_limiter_horz                           = 100         ! zalesak
/
&ocean_horizontal_diffusion_nml
  laplacian_form                             = 1           ! 1=curlcurl-graddiv
  VelocityDiffusion_order                    = 2           ! 21=biharmonic+laplacian (for the laplacian leith)
!
! BiharmonicViscosity_scaling                = 1           ! 1: no scaling used in XPP1 for r2b6
! BiharmonicViscosity_reference              = 3.5E12      ! [m2/s] constant biharmonic horizontal viscosity coefficient for velocity
  BiharmonicViscosity_scaling                =  4          ! 4: scaling with edge-length - used for XPP2
  BiharmonicViscosity_reference              =  2.7E-2     ! [m2/s] horizontal viscosity coefficient for velocity scaled
  BiharmonicViscosity_background             = 0.0
!
  HarmonicViscosity_scaling                  = 1
  HarmonicViscosity_reference                = 0.0         ! [m2/s] constant horizontal viscosity coefficient for velocity
  HarmonicViscosity_background               = 0.0
!
  TracerHorizontalDiffusion_scaling          = 1
  Temperature_HorizontalDiffusion_Background = 0.0
  Temperature_HorizontalDiffusion_Reference  = 0
  Salinity_HorizontalDiffusion_Background    = 0.0
  Salinity_HorizontalDiffusion_Reference     = 0
/
&ocean_vertical_diffusion_nml
  vert_mix_type                              = 2           ! 1: PP; 2: TKE
  PPscheme_type                              = 0           ! 4: latest PPscheme - 0: switched off
!
!  Parameters for TKE-type vertical mixing
  ! cvmix/tke parameters
  c_k                                        = 0.1	!0.075       !  (default = 0.1)
  c_eps                                      = 0.7
  alpha_tke                                  = 30.0
  mxl_min                                    = 1.d-8
  use_Kappa_min                              = .TRUE.     !  use kappaH_min
  kappaH_min                                 = 2.0e-5  ! 1.5e-5  !  def=1.0e-5
  kappaM_min                                 = 0.0
  kappaM_max                                 = 100.0
  cd                                         = 3.75
  tke_min                                    = 1.d-6
  tke_mxl_choice                             = 2
  tke_surf_min                               = 1.d-4
  only_tke                                   = .TRUE.
  l_lc                                       = .TRUE.      ! Use Langmuir parameterisation (Axell, 2002)
  clc                                        = 0.15        ! Factor in the vertical velocity profile of the Langmuir
                                                           ! circulation (default clc=0.1 in Axell (2002))
  use_ubound_dirichlet                       = .FALSE.
  use_lbound_dirichlet                       = .FALSE.
/
&ocean_GentMcWilliamsRedi_nml
  GMRedi_configuration                       = 1           ! 0=cartesian diffusion; 1=GM-Redi: bolus advection + isopycnal diffusion
  tapering_scheme                            = 1
  GMRedi_usesRelativeMaxSlopes               = .FALSE.
  S_max                                      = 1.0e-3      ! 3e-5
  S_d                                        = 1.0e-4      ! 1e-3 to 1e-4
                                                           !
  k_tracer_GM_kappa_parameter                = 400.0      !
  k_tracer_isoneutral_parameter              = 400.0      ! value for cell-based cartesian diffusion - mpiom: 1000/400km = 400/160km
  k_tracer_dianeutral_parameter              = 0.0         ! 1.0E-5  !
                                                           !
  switch_off_diagonal_vert_expl              = .TRUE.
  gmredi_combined_diagnostic                 = .FALSE.
! switch_on_redi_balance_diagnostic          = .FALSE.     ! not yet available in icon-aes-dyamond++
  revert_vertical_recon_and_transposed       = .TRUE.
  slope_calc_via_temperture_salinity         = .TRUE.
  include_slope_squared_implicit             = .TRUE.      ! think of l_with_vert_tracer_diffusion
  switch_on_tapering_horizontal_diffusion    = .TRUE.
/
&ocean_physics_nml
  i_sea_ice                                  = 1           ! 0 = no sea ice; 1 = sea ice model on; default=1
  lhamocc                                    = ${lhamocc}
  lbgcadv                                    = ${lbgcadv}
/                                           
&sea_ice_nml
  i_ice_therm                                = 1           ! 1=zero-layer (default), 2=Winton, 0/2: not allowed
  i_ice_dyn                                  = 1           ! 1/0=switch on/off AWI ice dynamics
  !i_Qio_type                                 = 3           ! 3 (default): energy of whole grid-area used for melting (MPIOM-type)
  !use_constant_tfreez                        = .TRUE.      ! default: TRUE
  !use_no_flux_gradients                      = .FALSE.     ! default: TRUE
  !hmin                                       = 0.05        ! default: 0.05 - minimum sea-ice value for ice
  stress_ice_zero                            = .FALSE.     ! default: TRUE
  leadclose_1                                = 0.25        ! default: 0.5 - value of MPIOM: 0.25
  leadclose_2n                               = 0.0 ! 0.666 ! default: 0.0 - value of MPIOM: 2/3
  !albedoW_sim                                = 0.10        ! albedo of the ocean used in sea ice model
  !pstar                                      = 40000.      ! default: 27500.; MPIOM=20000.
  luse_replacement_pressure                  = .TRUE.      ! hel24182 - def: F
  delta_min                                  = 2.0e-9      ! hel24182 - def: 2.e-11
  cd_io                                      = 5.5e-3      ! hel24182 - def: 3.0e-3
/
EOF

cat >> ${oce_namelist} << EOF
&ocean_forcing_nml
  !use_sst_nudging                            = .TRUE.
  iforc_oce                                  = 14          ! ocean forcing: 14 from coupling via YAC
  type_surfRelax_Temp                        = -1          ! -1: use net surface heat flux from atmosphere
                                                           !  0: no relaxation used
                                                           !  1: relaxation switched on for reading (init_oce_relax=1)
                                                           !     or some testcases only
  forcing_enable_freshwater                  = .TRUE.      ! enable/disable freshwater flux
  forcing_windstress_u_type                  = 2           ! 0: zero wind stress, 1: read from file, 2: none
  forcing_windstress_v_type                  = 2           ! 0: zero wind stress, 1: read from file, 2: none
                                                           ! salt-change due to internal fluxes only
  limit_seaice                               = .TRUE.      ! default: TRUE
  seaice_limit                               = ${limitice} ! hard limit set to factor of flat upper layer thickness for sea ice
  lfix_salt_content                          = .TRUE.
  limit_elevation                            = .FALSE.     ! true: adjust daily to zero, default=false: free surface
! lswr_jerlov                                = .FALSE.     ! SW-penetration (Jerlov-radiation, default=T)
/
EOF
#
if [[ "$initialiseOcean" == "fromRestart" ]] || [[ "$initialiseOcean" == "fromRestartwithHamocc" ]]; then
  #
  cat >> ${oce_namelist} << EOF
&ocean_initialConditions_nml
  initial_salinity_type                      = 0                ! 0: none, 1: read S from initial_state.nc
  initial_temperature_type                   = 0                ! 0: none, 1: read T from initial_state.nc
  !sea_surface_height_type                    = 0                ! >= 200 sea_surface_height
  !initial_velocity_type                      = 0
  initialize_fromRestart                     = .TRUE.
/
EOF
#
else
#
  if [[ "$initialiseOcean" == "fromClimatology" ]]; then
    cat >> ${oce_namelist} << EOF
&ocean_initialConditions_nml
  initial_salinity_type                      = 1                ! 0: none, 1: read S from initial_state.nc
  initial_temperature_type                   = 1                ! 0: none, 1: read T from initial_state.nc
  !sea_surface_height_type                    = 1               ! not for reading T and S from ts_phc! 
  !initial_velocity_type                      = 1
  initialize_fromRestart                     = .FALSE.
/
EOF
  else
    cat >> ${oce_namelist} << EOF
&ocean_initialConditions_nml
  initial_salinity_type                      = 0                ! 0: none, 1: read S from initial_state.nc
  initial_temperature_type                   = 0                ! 0: none, 1: read T from initial_state.nc
  sea_surface_height_type                    = 0                ! 0: no reset
  initial_velocity_type                      = 0                ! 0: no reset
  initialize_fromRestart                     = .FALSE.
/
EOF
  fi
fi
#
cat >> ${oce_namelist} << EOF
&ocean_diagnostics_nml
  diagnostics_level                          = 1
  diagnose_for_horizontalVelocity            = .FALSE.
  diagnose_for_heat_content                  = .TRUE.
/
&io_nml
  restart_file_type                          = 5
  !write_last_restart                         = .TRUE.           ! def=F; T: force writing restart at end of job
  restart_write_mode                         = "joint procs multifile"  ! not yet available in ocean model
  lnetcdf_flt64_output                       = .FALSE.          ! T: 64 bit output in all files
  lkeep_in_sync                              = .TRUE.           ! sync after each timestep
/
EOF

# cat namelist
cat $oce_namelist

add_required_file ${basedir}/run/${oce_namelist} ./

#-----------------------------------------------------------------------------
#
# Ocean initialisation input
# add spun-up ocean-only or ocean restart of coupled experiments
#
if [[ "$initialiseOcean" == "fromRestart" ]]; then
  #  XPP: restarts without subdir "restart":
  add_link_file ${restart_dir}/${restart_exp}/${restart_exp}_restart_oce_${restart_yea}0101T000000Z.nc init-restart-oce.nc
  add_link_file init-restart-oce.nc multifile_restart_ocean.mfr
fi

if [[ "$initialiseOcean" == "fromClimatology" ]]; then
 ## for init with en4 of 1950y: R2B6/L72
  #INDIR="$ICONcoupled/HH-oras5_en4"
  #add_link_file $INDIR/ts_en4_icon_grid_0035_modsill_L72.nc initial_state.nc
  #add_link_file $INDIR/ts_en4_L72_1950y.nc initial_state.nc

  ## for initializing from PHC3.0: R2B6/L72
  INDIR="$ICONcoupled/HH-L72sml"
  add_link_file $INDIR/ts_phc3.0_annual.L72sml.nc initial_state.nc

  # hd input
  #datadir=${clim_data_poolFolder}/indepedent/hd/input/05deg
  #ln -sf $datadir/hdstart_05.nc ${experiments_dir}/${EXPNAME}/hdstart.nc
fi

#
# Ocean grid
#  #slo - move to grid section
#
add_link_file ${ocean_grid_folder}/${ocean_grid_target} ./${ocean_grid_target}
#
# didi: add qflux file
#add_link_file /work/mh0033/m211054/projects/icon/devel/m211054-anomaly-coupling/fluxadjust/r2b6/fluxadjust.nc.test2 fluxadjust.nc
#add_link_file /work/kd1418/m301118/icon_run/icon-flux/icon-mpim/flux/flux_correction_tropics_iter7.nc fluxadjust.nc
#add_link_file /work/kd1418/m301118/flux/flux_correction_tropics.nc fluxadjust.nc
add_link_file /work/mh1421/m300466/obs_reanal/ERSSTv5/ERSSTv5_1950_r2b6O.nc fluxadjust.nc
#
## HAMOCC forcing files
#
if [  "x${use_hamocc}"  = "xyes" ]; then
  # FIXME: this is still a private path
  datadir=/work/mh0727/m300732/input/0036/ocean/hamocc/
  add_link_file $datadir/MAHOWALDDUST_icon_grid_0036_R02B04_O_remapbil1.nc           dust.nc  # iron deposition
  add_link_file $datadir/ndepo_1-0_gr_185001-185012-clim_icon_grid_0036_R02B04_O.nc  nitrogen.nc  # nitrate deposition
fi
#
#-----------------------------------------------------------------------------

if [ $mpi_total_procs -lt `expr $mpi_oce_procs + 1` ] ; then
   echo "Too few mpi_total_procs for requested mpi_oce_procs."
   echo "-> check mpi_total_procs and mpi_oce_procs. Exiting."
   check_error 0
   exit
fi

#-----------------------------------------------------------------------------
#
# Following: automatically appended section to start the model integration. 
#
#=============================================================================
#
# This section of the run script prepares and starts the model integration. 
#
# MODEL and START must be defined as environment variables or
# they must be substituted with appropriate values.
#
# Marco Giorgetta, MPI-M, 2010-04-21
#
#-----------------------------------------------------------------------------
final_status_file=${basedir}/run/${job_name}.final_status
rm -f ${final_status_file}
#-----------------------------------------------------------------------------
#
# directories definition
#
RUNSCRIPTDIR=${basedir}/run
if [ x$grids_folder = x ] ; then
   HGRIDDIR=${basedir}/grids
else
   HGRIDDIR=$grids_folder
fi

make_and_change_to_experiment_dir

for dir in ${ADDITIONAL_SUBDIRS[@]}; do
  mkdir -p $dir
done

#-----------------------------------------------------------------------------
final_status_file=${RUNSCRIPTDIR}/${job_name}.final_status
rm -f ${final_status_file}

#-----------------------------------------------------------------------------
# set up the model lists if they do not exist
# this works for single model runs
# for coupled runs the lists should be declared explicilty
if [ x$namelist_list = x ]; then
#  minrank_list=(        0           )
#  maxrank_list=(     65535          )
#  incrank_list=(        1           )
  minrank_list[0]=0
  maxrank_list[0]=65535
  incrank_list[0]=1
  if [ x$atmo_namelist != x ]; then
    # this is the atmo model
    namelist_list[0]="$atmo_namelist"
    modelname_list[0]="atmo"
    modeltype_list[0]=1
    run_atmo="true"
  elif [ x$ocean_namelist != x ]; then
    # this is the ocean model
    namelist_list[0]="$ocean_namelist"
    modelname_list[0]="oce"
    modeltype_list[0]=2
  elif [ x$psrad_namelist != x ]; then
    # this is the psrad model
    namelist_list[0]="$psrad_namelist"
    modelname_list[0]="psrad"
    modeltype_list[0]=3
  elif [ x$hamocc_namelist != x ]; then
    # this is the hamocc model
    namelist_list[0]="$hamocc_namelist"
    modelname_list[0]="hamocc"
    modeltype_list[0]=4
  elif [ x$jsbach_namelist != x ]; then
    # this is the jsbach standalone model
    namelist_list[0]="$jsbach_namelist"
    modelname_list[0]="jsbach"
    modeltype_list[0]=5
    run_jsbach_standalone="true"
  elif [ x$testbed_namelist != x ]; then
    # this is the testbed model
    namelist_list[0]="$testbed_namelist"
    modelname_list[0]="testbed"
    modeltype_list[0]=99
  else
    check_error 1 "No namelist is defined"
  fi 
fi

#-----------------------------------------------------------------------------
# set some default values and derive some run parameteres
restart=${restart:=".false."}
restartSemaphoreFilename='isRestartRun.sem'
#AUTOMATIC_RESTART_SETUP:
if [ -f ${restartSemaphoreFilename} ]; then
  restart=.true.
  #  do not delete switch-file, to enable restart after unintended abort
  #[[ -f ${restartSemaphoreFilename} ]] && rm ${restartSemaphoreFilename}
  ln -s ${experiments_dir}/${EXPNAME}/hdrestart_${current_year}.nc hdstart.nc
else
  if [[ "$initialiseOcean" == "fromExperiment" ]]; then
    restart=.true.
    add_link_file ${restart_dir}/${restart_exp}/${restart_exp}_restart_atm_${restart_yea}0101T000000Z.nc init-restart-atm.nc
    add_link_file ${restart_dir}/${restart_exp}/${restart_exp}_restart_oce_${restart_yea}0101T000000Z.nc init-restart-oce.nc
    add_link_file ${restart_dir}/${restart_exp}/hdrestart_${restart_yea}.nc                              init-restart-hd.nc
    #add_link_file init-restart-atm.nc restart_atm_DOM01.nc         # single restart filename
    #add_link_file init-restart-oce.nc restart_ocean_DOM01.nc       # single restart filename
    #add_link_file init-restart-atm.nc multifile_restart_atm.mfr    # multifile restart filename
    #add_link_file init-restart-oce.nc multifile_restart_ocean.mfr  # multifile restart filename

    #  XPP: restarts without subdir "restart":
    #ln -s ${restart_dir}/${restart_exp}/${restart_exp}_restart_atm_${restart_yea}0101T000000Z.nc init-restart-atm.nc
    # ln -s ${restart_dir}/${restart_exp}/${restart_exp}_restart_oce_${restart_yea}0101T000000Z.nc init-restart-oce.nc
    # ln -s ${restart_dir}/${restart_exp}/hdrestart_${restart_yea}.nc                              init-restart-hd.nc

    #  Helmuth: restarts in $exp/restart:
    #ln -s ${restart_dir}/${restart_exp}/restart/${restart_exp}_restart_atm_${restart_yea}0101T000000Z.nc init-restart-atm.nc
    #ln -s ${restart_dir}/${restart_exp}/restart/${restart_exp}_restart_oce_${restart_yea}0101T000000Z.nc init-restart-oce.nc
    #ln -s ${restart_dir}/${restart_exp}/restart/hdrestart_${restart_yea}.nc                              init-restart-hd.nc

    #ln -s init-restart-atm.nc restart_atm_DOM01.nc         # single restart filename
    #ln -s init-restart-oce.nc restart_ocean_DOM01.nc       # single restart filename

    # multifile restart filename - delete if already exists
    #multilink= multifile_restart_ocean.mfr
    #[[ -f $multilink ]] && rm $multilink - use add_link_file, includes rm
    add_link_file init-restart-atm.nc multifile_restart_atmo.mfr    # multifile restart filename
    add_link_file init-restart-oce.nc multifile_restart_ocean.mfr  # multifile restart filename
    add_link_file init-restart-hd.nc  hdstart.nc                   # single restart filename for HD
    #ln -s init-restart-atm.nc multifile_restart_atmo.mfr    # multifile restart filename
    #ln -s init-restart-oce.nc multifile_restart_ocean.mfr  # multifile restart filename
    #ln -s init-restart-hd.nc  hdstart.nc                   # single restart filename for HD
  fi
fi
#END AUTOMATIC_RESTART_SETUP
#
# wait 5min to let GPFS finish the write operations
if [ "x$restart" != 'x.false.' -a "x$submit" != 'x' ]; then
  if [ x$(df -T ${EXPDIR} | cut -d ' ' -f 2) = gpfs ]; then
    sleep 10;
  fi
fi
# fill some checks

run_atmo=${run_atmo="false"}
if [ x$atmo_namelist != x ]; then
  run_atmo="true"
  run_jsbach_standalone="false"
fi
run_jsbach=${run_jsbach="false"}
if [ x$jsbach_namelist != x ]; then
  run_jsbach="true"
fi
run_ocean=${run_ocean="false"}
if [ x$ocean_namelist != x ]; then
  run_ocean="true"
fi
run_psrad=${run_psrad="false"}
if [ x$psrad_namelist != x ]; then
  run_psrad="true"
fi
run_hamocc=${run_hamocc="false"}
if [ x$hamocc_namelist != x ]; then
  run_hamocc="true"
fi

#-----------------------------------------------------------------------------
# add grids to required files
all_grids="${atmo_dyn_grids} ${atmo_rad_grids} ${ocean_grids}"
for gridfile in ${all_grids}; do
  #
  gridfile=${gridfile//\'/} # strip all ' in case ' is used to delimit the grid names
  gridfile=${gridfile//\"/} # strip all " in case " is used to delimit the grid names
  gridfile=${gridfile//\,/} # strip all , in case , is used to separate the grid names
  #
  grfinfofile=${gridfile%.nc}-grfinfo.nc
  #
  ls -l ${HGRIDDIR}/$gridfile
  check_error $? "${HGRIDDIR}/$gridfile does not exist."
  add_link_file ${HGRIDDIR}/${gridfile} ./
  if [ -f ${HGRIDDIR}/${grfinfofile} ]; then    
    add_link_file ${HGRIDDIR}/${grfinfofile} ./
  fi
done
#-----------------------------------------------------------------------------
# print_required_files
copy_required_files
link_required_files

#-----------------------------------------------------------------------------
# get restart files

if  [ x$restart_atmo_from != "x" ] ; then
  rm -f restart_atm_DOM01.nc
#  ln -s ${basedir}/experiments/${restart_from_folder}/${restart_atmo_from} ${EXPDIR}/restart_atm_DOM01.nc
  cp ${basedir}/experiments/${restart_from_folder}/${restart_atmo_from} cp_restart_atm.nc
  ln -s cp_restart_atm.nc restart_atm_DOM01.nc
  restart=".true."
fi
if  [ x$restart_ocean_from != "x" ] ; then
  rm -f restart_oce.nc
#  ln -s ${basedir}/experiments/${restart_from_folder}/${restart_ocean_from} ${EXPDIR}/restart_oce.nc
  cp ${basedir}/experiments/${restart_from_folder}/${restart_ocean_from} cp_restart_oce_DOM01.nc
  ln -s cp_restart_oce_DOM01.nc restart_oce_DOM01.nc
  restart=".true."
fi
#-----------------------------------------------------------------------------


read_restart_namelists=${read_restart_namelists:=".true."}

#-----------------------------------------------------------------------------
#
# create ICON master namelist
# ------------------------
# For a complete list see Namelist_overview and Namelist_overview.pdf

#-----------------------------------------------------------------------------
# create master_namelist
if [ -z "$dont_create_icon_master_namelist" ]; then
  master_namelist=icon_master.namelist

  calendar=${calendar:="proleptic gregorian"}
  calendar_type=${calendar_type:=1}
  {
    echo "&master_nml"
    echo " lrestart               =  $restart"
    echo " read_restart_namelists =  $read_restart_namelists"
    echo "/"

    if [ -z "$nsteps" ]; then
      echo "&master_time_control_nml"
      echo " calendar             = '$calendar'"
      echo " experimentStartDate  = '$start_date'"
      echo " restartTimeIntval    = '$restart_interval'"
      echo " checkpointTimeIntval = '$checkpoint_interval'"
      if [ -n "$end_date" ]; then
        echo " experimentStopDate = '$end_date'"
      fi
      echo "/"

      echo "&time_nml"
      echo " is_relative_time     = .false."
      echo "/"

    else # $nsteps is set -> use time_nml:ini_datetime_string
      echo "&time_nml"
      echo " calendar             =  $calendar_type"
      echo " ini_datetime_string  = '$start_date'"
      echo " dt_restart           =  $dt_restart"
      echo "/"
    fi
  } > $master_namelist

fi
#-----------------------------------------------------------------------------

#-----------------------------------------------------------------------------
# add model component to master_namelist
add_component_to_master_namelist()
{
  model_namelist_filename=$1
  if [ x${dont_create_icon_master_namelist+set} != xset ]; then
    model_name=$2
    model_type=$3
    model_min_rank=$4
    model_max_rank=$5
    model_inc_rank=$6
    model_rank_group_size=$7
    cat >> $master_namelist << EOF
&master_model_nml
  model_name="$model_name"
  model_namelist_filename="$model_namelist_filename"
  model_type=$model_type
  model_min_rank=$model_min_rank
  model_max_rank=$model_max_rank
  model_inc_rank=$model_inc_rank
  model_rank_group_size=$model_rank_group_size
/
EOF
  fi

  #-----------
  #get namelist
  if [ -f ${RUNSCRIPTDIR}/$model_namelist_filename ] ; then
    mv -f ${RUNSCRIPTDIR}/$model_namelist_filename ${EXPDIR}
    check_error $? "mv -f ${RUNSCRIPTDIR}/$model_namelist_filename ${EXPDIR}"
  else
    check_error 1 "${RUNSCRIPTDIR}/$model_namelist_filename does not exist"
  fi
}
#-----------------------------------------------------------------------------


no_of_models=${#namelist_list[*]}
echo "no_of_models=$no_of_models"

rank_group_size=1
j=0
while [ $j -lt ${no_of_models} ]
do
  add_component_to_master_namelist "${namelist_list[$j]}" "${modelname_list[$j]}" ${modeltype_list[$j]} ${minrank_list[$j]} ${maxrank_list[$j]} ${incrank_list[$j]} ${rank_group_size}
  j=`expr ${j} + 1`
done

#-----------------------------------------------------------------------------
# Add JSBACH part to master_namelist
# For several domains, $jsbach_namelist is only the basename for each domain's jsbach namelist;
#   the actual namelist files are appended by suffixes '_d1', '_d2', etc.

if [[ $run_jsbach == yes  ]] || [[ $run_jsbach == true ]]; then
  cat >> $master_namelist << EOF
&jsb_control_nml
 is_standalone      = .${run_jsbach_standalone:=false}.
 restart_jsbach     = ${restart}
 debug_level        = 0
 timer_level        = 0
/
EOF
#
if [[ -n ${atmo_dyn_grids} ]]; then
  no_of_domains=${#atmo_dyn_grids[@]}
else
  no_of_domains=1
fi
echo "no_of_domains=$no_of_domains"
domain=""
domain_suffix=""
j=1
while [ $j -le ${no_of_domains} ]
do
  if [[ $no_of_domains -gt 1 ]]; then
    # no_of_domains < 10 !
    domain=" DOM0${j}"
    domain_suffix="_d${j}"
  fi
  cat >> $master_namelist << EOF
&jsb_model_nml
 model_id = $j
 model_name = "JSBACH${domain}"
 model_shortname = "jsb${domain_suffix}"
 model_description = 'JSBACH land surface model'
 model_namelist_filename = "${jsbach_namelist}${domain_suffix}"
/
EOF
  if [[ ${run_jsbach_standalone} != true ]]; then
    if [[ -f ${RUNSCRIPTDIR}/${jsbach_namelist}${domain_suffix} ]] ; then
      mv ${RUNSCRIPTDIR}/${jsbach_namelist}${domain_suffix} ${EXPDIR}
      check_error $? "mv ${RUNSCRIPTDIR}/${jsbach_namelist}${domain_suffix}"
    else
      check_error 1 "${RUNSCRIPTDIR}/${jsbach_namelist}${domain_suffix} does not exist"
    fi
  fi
  j=`expr ${j} + 1`
done
fi

#
#  get model
#
ls -l ${MODEL}
check_error $? "${MODEL} does not exist?"
#
ldd ${MODEL}
#


if [[ $HDmode = "HDext" ]] ; then
#-----------------------------------------------------------------------------
#
# HD Namelist
#
## Log output for gridboxes if nhd_diag=100
xlon1=8.5
xlat1=54.5
xlon2=10.5
xlat2=53.5
## Type of Interpolation from input (atmospheric) grid to HD grid
##          0   Input = Output
##          1   using HDMAP routine by Veronika (default)
##          2   0.5 degree to 5 Min./
IMAP=0
## Coupling type: 0=no, 1=no interpolation, 2=interpolation in HD
ICOUPLE=1
## User specific settings that will be put as attributes in the output file
## via namelist HDUSER_CTL in file namelist.hduser
HD_USER="Trang Van Pham"
HD_INST="Deutscher Wetterdienst, Germany"
HD_INSTID=""
EMAIL_ADDRESS="trang.pham-van@dwd.de"

if (( $ICOUPLE != 2 )) ; then
   lcoup_out=.FALSE.
else
   lcoup_out=.TRUE.
fi

cat > namelist.hd << end_hd_ctl
&HD_CTL
  date_start    = ${current_year}0101
  date_end      = ${stop_year}1231
  delta_time    = ${dt}                                       !! 3600 ! 7200 ! 14400 ! 21600 ! 28800 ! 43200 ! 86400
  runoff_file   = ""
  drainage_file = ""
  forcing_freq  = 0                 ! 0: stepwise, 1: daily
  IOUT          = 6                 ! 5: monthly, 6: daily
  UFAKRU        = 0.001             ! Input is mm/s = kg m-2 s-1
  coupling_type = ${ICOUPLE}        !
  coupling_file = "${DNCOUPLE}"
  lcoupling_out = ${lcoup_out}      ! Write discharge on ocean grid dep. on IOUT (couling_type 2 only)
  iform_input   = 1                 ! Format Input files: 0 = SRV (Default), 1 = NetCDCF
  lcoupling_atm = .TRUE.
  lcoupling_oce = .TRUE.
  out_expname   = ${EXPNAME}
  out_datapath  = "${experiments_dir}/${EXPNAME}/"
  icpl_mask_tohd= 2
  icpl_sinks    = 1
/
end_hd_ctl

cat > namelist.hdset << end_hydrology_ctl
&HYDROLOGY_CTL
  ldebughd          = .FALSE.
  diag_water_budget = .FALSE.
  locean            = .FALSE.  ! closure of water budget for ocean coupling
  nhd_diag          =  7
  lhd_highres       = .FALSE.  ! .TRUE.: CALL hd_highres_write --> /output/hd/hd_YYYY_MM_02_hd_highres.nc
  fllog1 = ${xlon1}
  fblog1 = ${xlat1}
  fllog2 = ${xlon2}
  fblog2 = ${xlat2}
  nremap = ${IMAP}
  lhd_rout = .FALSE.
! Factors to allow sensitivity studies on 5 Min.
  fk_rfk = 1.
  fk_lfk = 1.
  fk_gfk = 1.
! Discharge dependent riverflow velocity (irf_vel <> 0)
  irf_vel = 1
  qrf_ref = 1000.
/
end_hydrology_ctl

cat > namelist.hduser << end_hduser_ctl
&HDUSER_CTL
  hd_user   = "${HD_USER}"
  hd_cont   = "${EMAIL_ADDRESS}"
  hd_inst   = "${HD_INST}"
  hd_instid = "${HD_INSTID}"
/
end_hduser_ctl

# multi-prog run
# ---------------------------
nstart=0
nend=$oce_max_rank
echo ${nstart}"-"${nend} $MODEL    > mpmd.lst

nstart=$((oce_max_rank + 1))
nend=$((oce_max_rank + 1))
echo ${nstart}"-"${nend} $HDMODEL >> mpmd.lst
cat mpmd.lst

START_MODEL=$START

else  #  HDint

#
#-----------------------------------------------------------------------------
#
# start experiment
#

# Combine START and MODEL if START_MODEL is not already set.
# START_MODEL is used to ease the execution of a machine that uses a complex
# mpirun command with multiple binaries
START_MODEL="${START_MODEL:=$START $MODEL}"
fi  #  HDext/HDint

rm -f finish.status

#
#remove any outputs that was created from a previously failed job - do not delete restart files
#rm -f ${EXPNAME}_???_*_${current_year}*T000000Z.nc
rm -f ${EXPNAME}_???_*_${current_year}0101T000000Z.nc
#
date
set -x
${START_MODEL} || exit 1
#set +x
date
#

cp ${experiments_dir}/${EXPNAME}/finish_atmo.status finish.status
if [ -r finish.status ] ; then
#  check_final_status 0 "${START} ${MODEL}"
  check_final_status 0 "${START}"  
else
  check_final_status -1 "${START} ${MODEL}"
fi

# Clean up:
#HD output files:
#mv ${experiments_dir}/${EXPNAME}/hd_outflow_07.log ${experiments_dir}/${EXPNAME}/${EXPNAME}_outflow_07_${current_year}.log

#Update year.log:
echo ${next_year} > ${experiments_dir}/${EXPNAME}/year.log
#mv ${experiments_dir}/${EXPNAME}/hdrestart.nc ${experiments_dir}/${EXPNAME}/hdrestart_${next_year}.nc
#rm ${experiments_dir}/${EXPNAME}/hdstart.nc
#
#-----------------------------------------------------------------------------
#
finish_status=`cat finish.status`
echo $finish_status
echo "============================"
echo "Script run successfully: $finish_status"
echo "============================"

#-----------------------------------------------------------------------------
# rm output_schedule_steps*
#-----------------------------------------------------------------------------
if [[ "x$use_hamocc" = "xyes" ]]; then
# store HAMOCC log file
strg="$(ls -rt ${EXPNAME}_hamocc_EU*.nc* | tail -1 )"
prefx="${EXPNAME}_hamocc_EU_tendencies"
foo=${strg##${prefx}}
foo=${foo%%.*}
bgcout_file="bgcout_${foo}"
mv bgcout $bgcout_file
fi
#-----------------------------------------------------------------------------
namelist_list=""
#-----------------------------------------------------------------------------
# check if we have to restart, ie resubmit
#   Note: this is a different mechanism from checking the restart
if [ $finish_status = "RESTART" ] ; then
  echo "restart next experiment..."
  this_script="${RUNSCRIPTDIR}/${job_name}"
  echo 'this_script: ' "$this_script"
  touch ${restartSemaphoreFilename}
  cd ${RUNSCRIPTDIR}
  ${submit} $this_script $run_param_0
else
  [[ -f ${restartSemaphoreFilename} ]] && rm ${restartSemaphoreFilename}
fi

#-----------------------------------------------------------------------------
# automatic call/submission of post processing if available
if [ "x${autoPostProcessing}" = "xtrue" ]; then
  # check if there is a postprocessing is available
  cd ${RUNSCRIPTDIR}
  targetPostProcessingScript="./post.${EXPNAME}.run"
  [[ -x $targetPostProcessingScript ]] && ${submit} ${targetPostProcessingScript}
  cd -
fi

#-----------------------------------------------------------------------------

cd $RUNSCRIPTDIR

#-----------------------------------------------------------------------------

	
# exit 0
#
# vim:ft=sh
#-----------------------------------------------------------------------------
